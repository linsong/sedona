<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    29 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Architecture</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <script src='sedonadoc.js'></script>
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='setup.html'>Prev</a>
 | <a href='tutorial.html'>Next</a>
</div>
<h1 class='title'>Architecture</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="actors">Actors</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona is designed to empower non-programmers to graphically
assemble applications by wiring together predefined components.
It is useful to consider two primary <i>actors</i> involved
in building Sedona applications:
</p>

<ul>
<li><b>Developers</b> are software engineers who write <i>components</i>
using the Sedona programming languages.  These components include
function blocks, IO drivers, and packaged applications.  Components
are then bundled into modules and deployed as <i>kits</i>.
</li>

<li><b>Integrators</b> are typically domain experts who use
graphical tools to assemble applications from the components written
by developers.  Components are configured via their properties
and wired together with <i>links</i>.
</li>
</ul>

<p>
In the real world, users don't fit into these two buckets
so cleanly - most users fit into both camps.  But characterizing
users according to these two actors is useful for discussion.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="lang">Sedona Language</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona applications all start with software written in the
<a href='lang.html'>Sedona programming language</a>.  The Sedona
language is based on Java and C# - so if you are familiar with those
languages then you should have no problem learning Sedona.  Key
characteristics of the Sedona language include:
</p>

<ul>
<li>Familiar Java/C# syntax</li>
<li>Object oriented (inheritance, polymorphism, all that good stuff)</li>
<li>Component oriented (first class properties and actions, reflection,
    graphical assembly)</li>
<li>Single inheritance only (no interfaces)</li>
<li>Static memory model (no <code>new</code> keyword)</li>
<li>Semicolons are optional as statement separator</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="components">Components</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona's standard API includes a special class called <code>Component</code>.
Classes that extend <code>Component</code> are designed to be
used by integrators to assemble applications.  All components have
the following characteristics designed to enable component-oriented
application assembly:
</p>

<ul>
<li>Two byte component id for identity and naming inside an application</li>
<li>A short ASCII character name as a human label</li>
<li>Designed to be organized into a tree structure similar to your file system</li>
<li>Reflective <i>type</i></li>
<li>Named set of reflective <i>slots</i></li>
</ul>

<p>
Slots are the members of a component class that specify how
the component is exposed to an integrator during the assembly
process.  There are two types of slots: <i>property</i> defines
a configuration or runtime variable and <i>action</i> defines a
command that can be invoked.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="kits">Kits</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Developers write Sedona software organized into classes much
like C++, Java, or C#.  These classes are then packaged up
into a <i>kit</i>.  A kit is the primary unit of deployment,
versioning, and naming in the Sedona architecture.  A kit
is like a Java JAR file or a .NET DLL.
</p>

<p>
Kits are stored as a single file that ends with the ".kit" extension.
The file itself is a standard PKZIP file you can open using
your favorite zip tool.  Inside the kit file is an XML
<a href="schema.html#manifest">manifest</a>  file that specifies
meta-data about the kit such as its name, version, vendor,
and description.  The manifest also enumerates all the kit's
component types that are available for application assembly.
</p>

<p>
Kits are compiled from Sedona language source code using
the <code>sedonac</code> compiler.  During the compilation all
the classes in the kit are checked for validity, and compiled
into a special format called <i>IR</i> for <i>intermediate
representation</i>.  The IR format is a text based "assembly
language" for Sedona.  IR code is portable, which means one kit
file can be deployed for all platforms.  During this step the compiler 
also generates a Java classfile for each of the Sedona classes,
which can be run on the <a href='#java'>Java 
VM</a>.
</p>                                   

<!--/////////////////////////////////////////////////////////-->
<h1 id="scode">SCode</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona software deployed as kits still isn't quite ready for execution.
Even though we've compiled source language down to IR, we still
don't have a format suitable for machine execution.  The next step
is to compile a set of kits into a single file called an <i>scode
image</i>.  SCode is a very compact, binary representation of the
code, which is designed to be executed directly by the Sedona VM.
</p>

<p>
The <code>sedonac</code> compiler is used to compile a set of kits
into a binary ".scode" file.  During this compilation process the
following tasks are performed:
</p>

<ul>
<li>Layout method code in memory</li>
<li>Layout fields in memory</li>
<li>Layout reflection meta-data in memory</li>
<li>Optimize for big-endian or little-endian</li>
<li>Optimize for native platform pointer size</li>
<li>Link method calls to their memory locations</li>
</ul>

<p>
For performance, we optimize scode for a specific endianness
and pointer size - which means that an scode image is not
portable.  Typically this compilation step happens automatically
under the covers during device commissioning.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="vm">Sedona Virtual Machine</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Once a set of kits has been compiled into an scode file, we can
run the scode using the <i>Sedona Virtual Machine</i>,
or <i>SVM</i> for short.  The Sedona VM interprets the scode
and brings Sedona programs to life!
</p>

<p>
The VM itself is written in ANSI C and compiled for a target
hardware platform.  See the <a href='porting.html'>Porting</a>
chapter for instructions to get the SVM running on your target
device.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="java">Sedona on the Java VM</h1>
<!--/////////////////////////////////////////////////////////-->

<p> 
Sedona may also be run on a Java Virtual Machine.  When Sedona
source code is compiled into a kit file, the compiler generates
Java bytecode.  This allows you to use kit files like Java JAR
files.
</p>  

<p>
Running on the Java VM has a couple advantages over the SVM.
First, a Java VM such as HotSpot uses a sophisticated JIT to
compile and optimize Java bytecode to machine code at runtime.
This potentially allows Sedona to run much faster on Java.  Another
advantage is that you can tap into Java ecosystem for tools such
as debuggers.  You will probably find Java an easier environment
to use for testing and debugging your code.  Java will enforce 
array bounds checking and give you print stack traces with line 
numbers when exceptions are raised.  
</p>

<p>
However the resources and cost  required to run Sedona on Java make it an
unsuitable solution for most embedded devices. Java typically requires 
dozens of megabytes of RAM and depending on the vendor might require a 
runtime license fee.  The SVM is designed to run in as little as a 100KB 
making it ideal for embedded devices.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="apps">Sedona Applications</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Writing code in the Sedona programming language and building
kits is the domain of developers.  Developers build libraries
of ready-to-use components deployed as Sedona kits.  Integrators
can then use graphical programming tools to design <i>applications</i>
by assembling and linking component instances.
</p>

<p>
Due to their dynamic nature, Sedona applications are modeled and
persisted differently from kits and scode.  A Sedona application
is modeled as a tree of components.  Each component is assigned
a unique two byte identifier and a custom name.  Components
instances may also be customized by their configuration properties.
Links are used to establish relationships between components
to specify data and event flow within the application.
</p>

<p>
Sedona applications may be stored in two different file formats.
The <i>Sedona Application - XML</i> format uses the ".sax" file
extension.  The <i>Sedona Application - Binary</i> format uses
the ".sab" file extension and is a compact binary representation
of the application database.  The binary format is the one used
by the runtime on Sedona devices.  The <code>sedonac</code>
tool can be used to convert between the file formats.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="devices">Sedona Devices</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Of course the end goal of Sedona is to create programmable
smart devices.  This is where everything comes together.
The typical process of Sedona enabling a device:
</p>

<ul>
<li>Port the Sedona VM to the device's hardware platform</li>
<li>Enable the VM to run (typically loaded or run from FLASH on startup)</li>
<li>Enable commissioning of an scode image.  This allows integrators
to pick their own kits to use for applications.  In some low-end
devices the scode may be fixed or even in ROM.  Typically the scode is
loaded or stored in FLASH, and a pointer to the base address is passed to
the VM at boot time.</li>
<li>Enable load/save of the sab application file.  In some
cases an integrator may dump a whole new application into FLASH;
other times the application is assembled on the fly at runtime
and then saved to FLASH.  In dedicated devices the application might
be fixed or even stored in ROM.</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="workflow">Workflow</h1>
<!--/////////////////////////////////////////////////////////-->

<p>             
The diagram below illustrates the workflow for building and 
deploying Sedona applications to devices.
</p>                                        

<p style='text-align:center;'>
<img src='architecture.png' alt='Sedona Architecture' />
</p>

<p>
The developer workflow typically involves these steps:
</p>

<ol> 
<li>Build library of Sedona components in the Sedona programming language</li>
<li>Sedona components are compiled into kits using sedonac</li>
<li>Developers or integrators will choose which kits to install onto a device,
and then sedonac is used to link the kits into a binary scode image (this
step is often done under the covers by a high level tool)</li>
<li>The Sedona virtual machine and scode is loaded onto the device.  These
files may be predefined such as in ROM, or may be dynamically provisioned
over the network using the Sox protocol.</li>
</ol>

<p>
System integrators are often domain experts who build applications by wiring
together the Sedona components built by developers. These users typically use
graphical tools to assemble applications. Applications may be built on-line
with a live device using the Sox protocol. Or they may be built offline and
stored in a "sax" file. If the app is built offline, then it compiled into
a "sab" file with sedonac and installed onto the device at commissioning time 
using the Sox protocol.
</p> 

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='setup.html'>Prev</a>
 | <a href='tutorial.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>copyright()</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>
