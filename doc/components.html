<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    12 Sep 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Components</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='methods.html'>Prev</a>
 | <a href='reflection.html'>Next</a>
</div>
<h1 class='title'>Components</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona is a <i>component oriented</i> language, which means that programs
are developed as reusable chunks of code designed to be snapped together
much like Lego building blocks.  This chapter discusses components
themselves; the <a href='apps.html'>Apps</a> chapter discusses how
components are assembled into applications.
</p>

<p>
A component is any class that extends
<code><a href='sys/Component.html'>sys::Component</a></code>.
Components include several features:
</p>

<ul>
<li>Can define <a href='#properties'>property</a> fields</li>
<li>Can define <a href='#actions'>action</a> methods</li>
<li>Can be organized into a tree structure</li>
<li>Can be given a human friendly name (up to 7 ASCII characters)</li>
<li>Have a two byte identifier within an application</li>
<li>Can be linked within an application</li>
<li>Provides <a href='#callbacks'>callback methods</a> that can be overridden</li>
<li>Component types have <a href='reflection.html'>reflection</a> capability</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="properties">Properties</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Properties are normal instance fields that are annotated with
the <code>property</code> keyword.  Properties are how components
expose configuration and runtime state.  Properties are restricted
to the following types:
</p>

<ul>
<li><code>bool</code></li>
<li><code>byte</code></li>
<li><code>short</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>sys::Buf</code></li>
</ul>

<p>
Note that you must use the <b>:=</b> operator when assigning
values to properties.  See 
<a href='expr.html#propassign'>Assigning to Properties</a>
for details.
</p>

<!--/////////////////////////////////////////////////////////-->
<h2 id="configVsRuntime">Config vs Runtime</h2>
<!--/////////////////////////////////////////////////////////-->

Properties are either <i>config</i> or <i>runtime</i>.  Config
properties are persistent and typically are changed by the user.
Runtime properties are transient and are changed by the component
itself during runtime.  Properties are runtime by default unless
marked with the "config" facet.  A simple example:

<pre>
class FooServer extends Component
{
  @config property bool enabled
  @config property int port = 80
  property int count  // runtime prop
}
</pre>

<!--/////////////////////////////////////////////////////////-->
<h2 id="bufProperties">Buf Properties</h2>
<!--/////////////////////////////////////////////////////////-->

<p>
Properties typed as <code>Buf</code> are a bit special from
the primitive property types.  The biggest difference is that
primitives are by-value and can't be changed without setting
the field itself.  However, buffer properties are
always inlined and accessed by reference.  When declaring
a buffer property, the <code>inline</code> modifier
is implied.  The following example illustrates a buffer property
with a total capacity of 8 bytes:
</p>

<pre>
class Foo extends Component
{
  property Buf(8) blob
}
</pre>

<p>
Because buffer properties are accessed by reference, the framework
has no knowledge when the buffer is modified.  So it is the developer's
responsibility to notify the framework of a buffer change via
the <code>Component.changed</code> method (typically using
a slot literal):
</p>

<pre>
void updateBlob()
{
  blob.copyFromStr("wow!")
  changed(Foo.blob)
}
</pre>

<p>
Note that <code>changed</code> is called automatically when
setting primitive property types.  You should only manually
call <code>changed</code> for <code>Buf</code> properties.
</p>

<!--/////////////////////////////////////////////////////////-->
<h2 id="asStrProperties">AsStr Properties</h2>
<!--/////////////////////////////////////////////////////////-->

<p>
<code>Buf</code> is the only non-primitive property type
available.  However, it is a common case to store a <code>Str</code>
value in a <code>Buf</code> property.  If you know that a buffer
property will always store a null-terminated string, then you
should mark the property with the "asStr" facet:
</p>

<pre>
class Foo extends Component
{
  @config @asStr property Buf(8) descr
}
</pre>

<p>
The <code>Buf</code> size is the total capacity including
the null terminator - so in the example above we can store a
string with a max of seven characters.  The <code><a href='sys/Buf.html'>Buf</a></code>
class has convenience methods when storing a string such as
<code>toStr</code> and <code>copyFromStr</code>.
</p>

<p>
Marking a buffer property asStr has a couple of benefits:
</p>

<ul>
<li>Buffer overruns are handled to ensure that there is always
a null terminator during deserialization.</li>
<li>It lets higher levels of the framework treat the buffer
as more than raw binary data.  For example, asStr properties
are serialized as text rather than base64 in XML files.
</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="actions">Actions</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Actions are normal instance methods that are annotated with the
<code>action</code> keyword. Every action is implicitly defined to be <code>virtual</code>,
so they can be overridden. Actions are typically used as commands on a
component. As methods, actions "do something" rather than store or
display a value. Actions methods must be declared to return void and
must have zero or one parameter. If a parameter is specified then it
must be one of the following types:</p>

<ul>
<li><code>bool</code></li>
<li><code>int</code></li>
<li><code>long</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>sys::Buf</code></li>
</ul>

<p>
Examples of "actions in action":
</p>

<pre>
class Foo extends Component
{
  action void actionNoArg()
  {
    Sys.out.print("actionNoArg").nl()
  }

  @asStr action void actionStr(Buf x)
  {
    Sys.out.print(x.toStr()).nl()
  }
}

class FooOverride extends Foo
{
  override action void actionNoArg()
  {
    Sys.out.print("Override actionNoArg").nl()
  }
}
</pre>

<p>
Note that you can use the "asStr" facet to annotate an action that
takes a Buf, if the argument should be a null-terminated string.
</p>



<!--/////////////////////////////////////////////////////////-->
<h1 id="callbacks">Callbacks</h1>
<!--/////////////////////////////////////////////////////////-->


<p>
Any class that extends <code><a href='sys/Component.html'>sys::Component</a></code>
includes the following virtual methods.  
Each is called automatically by the system at the appropriate time.  
These callback methods may be overridden by
Component subclasses to change the behavior of the component.
</p>

<pre>
  virtual void loaded()
  virtual void start()
  virtual void execute()

  virtual void changed(Slot slot)
  virtual void setToDefault(Slot slot)

  virtual int  childEvent(int eType, Component child)
  virtual int  parentEvent(int eType, Component parent)
  virtual int  linkEvent(int eType, Link link)
</pre>


<p>
See the API documentation at <code><a href='sys/Component.html'>sys::Component</a></code>
for details on how these methods are used.
</p>



<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='methods.html'>Prev</a>
 | <a href='reflection.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







