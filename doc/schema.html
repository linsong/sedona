<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    17 May 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Schema</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='kits.html'>Prev</a>
 | <a href='platforms.html'>Next</a>
</div>
<h1 class='title'>Schema</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!-- /////////////////////////////////////////////////////// -->
<h1 id="overview">Overview</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Because Sedona is designed to work in very constrained embedded
environments, we have to make design tradeoffs.  One of the biggest
tradeoffs is using a low level binary format for Sedona application
files and the Sox protocol.  These binary formats require out-of-band
information for encoding and decoding.  For example the binary formats
assume you know how kit, type, and slot ids map to their definitions.
We must also design for versioning since kit schemas evolve
over time to include new types and new slots.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="checksums">Kit Checksums</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Every kit contains zero or more named types.  Each type declares
zero or more slots.  For a given version of a kit, there is a fixed
list of types and their declared slots.  Each slot has a fixed
name, flags, and type.  When a kit is compiled from source into
a kit zip file, the compiler generates a <i>checksum</i> for this fixed
list of types and slots.  The combination of a kit name and checksum
is called a <i>kit part</i>.
</p>

<p id="manifest">
The kit meta-data, checksum, and list of types and slots is included
in the kit file as an XML file called "manifest.xml".  Here is an example manifest file:
</p>

<pre>
&lt;?xml version='1.0'?>
&lt;kitManifest
   name="sysTest"
   checksum="da52f78f"
   version="1.0"
   vendor="Tridium"
   description="Test suite for core language and sys APIs"
   buildHost="BLAZE"
   buildTime="2007-05-17T16:21:08.030-04:00"
>

&lt;type id="0" name="AbstractTestComp" base="sys::Component">
  &lt;slot id="0" name="az" type="bool"/>
  &lt;slot id="1" name="ai" type="int"/>
&lt;/type>

&lt;type id="1" name="TestComp" base="sysTest::AbstractTestComp">
  &lt;slot id="0" name="z1" type="bool"/>
  &lt;slot id="1" name="b1" type="byte"/>
  &lt;slot id="2" name="addF1" type="float" flags="a"/>
&lt;/type>

&lt;type id="2" name="SubTestComp" base="sysTest::TestComp">
  &lt;slot id="0" name="sb" type="byte"/>
  &lt;slot id="1" name="si" type="int"/>
&lt;/type>

&lt;/kitManifest>
</pre>

<p>
The checksum is based only on the kit's types and slots.  The checksum is
not based on variable meta-data such as the kit's version number.  This
means that multiple versions of the same kit might share the same checksum
if no types or slots have been modified.  Don't confuse version with
checksum.  Version represents a revision of the whole kit including its
code, algorithms, and when it was built.  Checksum represents a revision
of the declared types and slots.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="kitDb">Kit Database</h1>
<!-- /////////////////////////////////////////////////////// -->

<p> 
Within a Sedona installation we store all the local copies of
kits with the file pattern: 
</p>                   

<pre>
{home}/kits/{kit}/{kit}-{checksum}-{version}.kit
{home}/kits/control/control-cdf5f0f0-1.0.29.kit
</pre>

<p>
We call this directory the <i>kit database</i>.  It can store
multiple concurrent versions of each kit.  The <code>sedona.kit.*</code>
APIs are used to work with the kit database.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="manifestDb">Manifest Database</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Kits always contain the manifest information we need when working
with schema.  However, to interface with the kit we don't need the full 
kit file, only the XML manifest inside of it.  So in addition to the kit 
database, we also store a manifest database with the file pattern:
</p>                                                       

<pre>      
{home}/manifests/{kit}/{kit}-{checksum}.xml
{home}/manifests/control/control-cdf5f0f0.xml
</pre>

<p>
By pulling the manifests out into a separate database, we don't
require the full kit file to work with the kit's types.  This is
typically more efficient, and it allows a manufacturer to only
publish the manifest versus the whole kit file.
</p>

<p>
The <code>sedona.manifest.*</code> APIs are used to work with manifests
and the manifest database via the Java toolkit.  The <code>KitManifest</code>
class represents the information stored a kit manifest file and provides
methods for encoding and decoding from XML.  The <code>ManifestDb</code>
class is used to load and save <code>KitManifests</code> to the file
system.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="schemas">Schemas</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
A Sedona runtime image or application is composed of multiple
kits.  A specific list of kit parts (kits at a specific checksum
revision) is called a <i>schema</i>.  Matching schemas guarantee
binary compatibility.
</p>

<p>
Only when a kit manifest is pulled into a specific schema do we
know information such as kit id and slot id.  For example the kit
id for "control" might be 3 in one schema, and 5 in another schema
that has a different list of kit parts.  Slot ids might also change
for a given kit part across schemas depending on the slots inherited
from base types.
</p>

<p>
The <code>sedona.*</code> APIs are used to work with schemas via
the Java toolkit.  Schemas are built with the <code>sedona.Schema</code>
class from a list of <code>KitParts</code> that are resolved against
the manifest database.  Assuming all the kit parts can be resolved to
kit manifests, we can build a complete representation of the schema
including the full list of kits, types, and slots along with
their respective ids.  The <code>Schema</code> is then used
to work with binary formats such as ".sab" files and Sox messages.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="resolvingManifests">Resolving Manifests</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The recommended rules for resolving a given kit name and
checksum to a manifest:
</p>

<ol>
<li>Check the local manifest database first, if found use it;</li>
<li>Check the local kit database, if found then copy the manifest
to the local manifest database for the next time around;</li>
<li>Download the manifest from Internet via sedonadev.org to the
local manifest database;</li>
</ol>                                                      

<p>
Steps 1 and 2 are automatically implemented by the <code>ManifestDb</code>
API.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="kitsVsManifests">Kits versus Manifests</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>         
So when do you need a kit and when do you only need a manifest?
This table helps summarize the differences:
</p>                                 

<table>

<tr>
  <th></th>
  <th>Encapsulates</th>
  <th>Versioned By</th>
  <th>Uses</th>
</tr>

<tr>
  <th>Manifest</th>
  <td>type and slot schema</td>
  <td>checksum</td>
  <td>sax, sab, and sox</td>
</tr>

<tr>
  <th>Kit</th>
  <td>code</td>
  <td>version number</td>
  <td>compiling dependencies and scode images</td>
</tr>
  
</table>

<p>
For example when working with an application file or Sox, only
the type schemas are needed.  No knowledge of the internal code
is required.  However when compiling, you need the full kit that 
contains the actual code.  
So a manifest is somewhat analogous to a C header
file, which declares function prototypes but does not contain any
code for the functions.
</p>                      

<p>
Manifests are versioned with a checksum each time a type or
slot definition is modified.  Kits are versioned with a version
number typically whenever code is modified.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="review">Review</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
To summarize the schema pipeline:
</p>

<ol>
  <li><b>Checksum</b>: Generated by the compiler when compiling a kit 
  file from source, the checksum is based on the declared types
and slots in the kit.</li>

<li><b>Kit Part</b>: The combination of kit name and kit
checksum that uniquely identifies a kit for a specific schema
revision.</li>

<li><b>Kit Manifest</b>: A file containing a kit's checksum
and type definitions, stored as a zip archive entry named "manifest.xml".
</li>

<li><b>Kit Database</b>: A database of all local kit versions,
created and maintained by the Sedona Java toolkit.  </li>

<li><b>Manifest Database</b>: A database of all the different kit manifests that
have been accumulated, created and maintained by the Sedona Java toolkit.
These manifests are XML files keyed by kit name and checksum.</li>

<li><b>Schema</b>: A list of kit parts aggregated by the Sedona Java toolkit.  
A schema defines the full meta-data required to work with binary format 
entities with matching schemas.  
Each Sedona runtime and application file has a single, fixed schema.  
The Java toolkit can model multiple
schemas simultaneously via the <code>sedona.Schema</code> API.</li>

</ol>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='kits.html'>Prev</a>
 | <a href='platforms.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>







