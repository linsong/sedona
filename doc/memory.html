<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2008 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    2 Jun 08  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Memory</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='arrays.html'>Prev</a>
 | <a href='nativeMethods.html'>Next</a>
</div>
<h1 class='title'>Memory</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Utilizing memory as efficiently as possible is a core requirement
for making the Sedona Framework run on small, embedded devices.  We divide
memory into the following sections:
</p>

<ul>
<li><b>Stack</b>: the call stack (RAM)</li>
<li><b>Data</b>: all the memory declared as static
fields in the current scode (RAM)</li>
<li><b>Sedona Framework App</b>: the components that define the current application (RAM)</li>
<li><b>Sedona Framework Code</b>: the scode image for the installed kits (RAM, or possibly flash memory)</li>
<li><b>SAB File</b>: the compact binary representation of the application (usually stored in flash) </li>
<li><b>C Code</b>: native code and SVM executable (RAM, or possibly flash)</li>
<li><b>C Data</b>: native code data segment (RAM)</li>
<li><b>C Stack</b>: the C native call stack (RAM)</li>
</ul>

<p>
We use the terms RAM and flash a bit loosely here:  RAM must be high
speed read/write memory, and flash is persistent memory (on a large device
this could be a disk drive).  If flash is high speed you might be able to
run code directly out of flash, but normally those code segments will
be loaded into RAM.
</p>

<p>
While reading this topic you may find it useful to refer to the Sedona VM
source code, located in the <code>src/vm</code> folder.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="computing">Computing Memory Requirements</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
So how do you figure out how much memory each of the sections
declared above requires?  Let's look at each section:
</p>

<h2>C Code, C Data, and C Stack</h2>

<p>
The C code, data, and stack segments will be determined by your development
tools and C compiler.  We use the term "C Code" to denote any non-Sedona code
such as C, C++, or assembly.  This code typically includes boot
code, OS code (if your device has one), all your native method
implementations, comm stacks, and the SVM itself.  All this is normally
lumped into a single binary executable file called "svm".  The C Data segment
includes all the memory buffers used by this code.
</p>

<p>
<b>Note:</b> On some platforms, part of the SVM may already be
in ROM or other permanent storage.  In that case the "svm" executable created during
compilation will contain only the portion of the SVM that is not in ROM, and
its RAM footprint will be reduced.
</p>

<h2>Stack</h2>

<p>
The Sedona stack is defined by the <code>stackBaseAddr</code> and <code>stackMaxSize</code>
fields of the <code>SedonaVM</code> struct when the VM is launched.
Typically the size is one or two KB - you may wish to test
your application to find the maximum call stack.  Heavy use of recursion and
methods with a large number of locals will affect your call stack size.
</p>

<h2>Code and Data</h2>

<p>
The sizes of the Sedona Code and Data segments are calculated when the scode
image is compiled:
</p>

<pre>
D:\sedona&gt;sedonac scode\x86-test.xml
  ReadKits [5 kits]
  WriteImage [D:\sedona\scode\x86-test.scode] (29632 bytes)
  +----------------------------------
  |  Data:      0.4kb (360 bytes)
  |  Code:     28.9kb (29632 bytes)
  |  Total:    29.3kb (29992 bytes)
  +----------------------------------
</pre>

<p>
These numbers are directly related to how many kits
you include and the code size of those kits.
Declaring static fields will consume memory in your Data segment;
instance fields only affect the application size.
If you are running your code out of RAM, then the Total size is what matters.
If you can run your code out of flash, then the Code will not use any RAM
but the Data segment must still be stored in RAM.
Note that the scode flags <code>test</code>
and <code>debug</code> can have a huge impact on scode size.
</p>

<p>
The location of the Code is passed to the VM in the <code>SedonaVM</code>
struct via the <code>codeBaseAddr</code> field.  The Data section
is allocated by the <code>malloc</code> macro - see "sedona.h" for details.
</p>

<h2>Sedona Framework Application</h2>

<p>
The Sedona Framework application itself is always run out of RAM.  This is where we
instantiate the components and links.  Memory for components and links is allocated
by the <code>malloc</code> macro.  If components or links are removed
during runtime, then the memory is freed by the <code>free</code> macro
(if the platform supports it).
</p>

<p>
The Sedona Framework application runs out of RAM, but has configuration data that
must be persistent between power cycles.  So we also store the
application to flash as a <a href='apps.html#sab'>SAB file</a>.  How
this file is loaded on startup and stored back to flash on save is handled
by the platform's implementation of the <code>sys::FileStore</code> native methods.
</p>

<p>
Sedonac will report how much RAM and flash a given application
consumes when you do a conversion between SAX or SAB:
</p>

<pre>
D:\sedona>sedonac apps\test.sax
  ConvertAppFile [D:\sedona\apps\test.sax -> D:\sedona\apps\test.sab]
  +----------------------------------
  |  RAM:     14.2kb (14588 bytes)
  |  FLASH:    0.4kb (382 bytes)
  +----------------------------------
</pre>

<p>
See the <a href='#layout'>Field Layout</a> section to evaluate how
much memory each component type consumes.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="heap">Heap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The memory for the Data section and for the
components and links in the App is allocated using the <code>malloc</code>
macro as defined in "sedona.h".  If components or links are removed
during runtime, then this memory is freed by the <code>free</code> macro.
You can implement your "heap management" using three strategies:
</p>

<ol>
<li><b>Stdlib</b>: if you have the resources, you can just use C's built-in
malloc and free.  However if using a compiler like GCC this might
require importing a huge chunk of library code into your native image.</li>
<li><b>Custom Heap</b>: if the stdlib implementation of malloc and free is
too big, you might consider writing your own simple heap manager.</li>
<li><b>Malloc Only</b>: many devices might require only a static application
in which case there is no requirement for freeing memory.  In resource
limited devices, the ability to free memory might be outweighed by the risk
of heap fragmentation.  In this case your heap management might be
nothing more than a pointer to the next chunk of memory to allocate.  A
call to free would be a no-op.  If objects are removed from the
application the memory would not be recovered until the system is reset.</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="layout">Field Layout</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
You can pass the <code>-layout</code> flag to sedonac when compiling
your scode image to dump the memory layout of each type.  This
gives you exact details for how memory is being consumed:
</p>

<ul>
<li>How many bytes each component type consumes in RAM</li>
<li>Memory offset of every instance field against the object's base address</li>
<li>Memory address of every static field against the Data base address</li>
</ul>

<p>
A good rule of thumb is that each component averages between 50 and 100
bytes and each link consumes 16 bytes.  A network protocol service
will typically consume several KB since it must allocate buffers
and internal data structures.  However, you really must use the
<code>-layout</code> flag to see exactly how many bytes each component
will consume.
</p>

<p>
Note that sedonac has no visibility into the behavior of native methods.
Any dynamic memory allocation that occurs at the native level must be
calculated separately and added manually to the totals provided by 
the <code>-layout</code> flag.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="hibernation">Hibernation</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona Framework supports <i>hibernation</i>, which allows a device to enter
a low power state.  The Sedona Framework assumes that during hibernation its data section
in RAM (managed by the heap <code>malloc</code> and  <code>free</code>
calls) will not be affected.  The device can either maintain RAM
during hibernation or save and restore to the same memory addresses.

See <a href='apps.html#hibernation'>Hibernation</a>.
</p>



<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='arrays.html'>Prev</a>
 | <a href='nativeMethods.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







