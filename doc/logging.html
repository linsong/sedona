<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    25 Sep 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Logging</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='nativeMethods.html'>Prev</a>
 | <a href='apps.html'>Next</a>
</div>
<h1 class='title'>Logging</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona Framework includes a built-in logging facility with
the following features:
</p>

<ul>
<li>Simple syntax to embed logging in your source code</li>
<li>Ability to selectively enable/disable logging at runtime</li>
<li>Ability to selectively compile logging in or out of an scode image</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="levels">Log Levels</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
There are five logging severity levels:
</p>

<ul>
<li><code>Log.NONE</code>: all logging is disabled</li>
<li><code>Log.ERROR</code>: indicates a failure condition</li>
<li><code>Log.WARNING</code>: indicates an unexpected condition</li>
<li><code>Log.MESSAGE</code>: indicates something of interest</li>
<li><code>Log.TRACE</code>: used to embed debug tracing</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="definition">Log Definition</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <a href='sys/Log.html'><code>sys::Log</code></a> class is the
primary API used for logging.  The <code>Log</code> class is a const
class like <code>Type</code> or <code>Slot</code>.  This means you can't
directly allocate instances yourself.  Instead we use the
<code>define</code> keyword to define a Log instance:
</p>

<pre>
class MyService
{
  define Log log
}
</pre>

<p>
Like other defines, the log is treated much like a static field.
During compilation all the log instances are compiled into the scode
as const data much like <code>Kit</code> instances.  The APIs for
log reflection follow a similar pattern to kit reflection:
</p>

<pre>
class Sys
{
  define int logsLen
  const static Log[logsLen] logs
  static inline byte[logsLen] logLevels

  static Log log(int id)
  static Log findLog(Str qname)

}

const class Log
{
  define int NONE = 0
  define int ERROR = 1
  define int WARNING = 2
  define int MESSAGE = 3
  define int TRACE = 4

  int level()
  bool isError()
  bool isWarning()
  bool isMessage()
  bool isTrace()

  OutStream error(Str msg)
  OutStream warning(Str msg)
  OutStream message(Str msg)
  OutStream trace(Str msg)

  const short id
  const Str qname
}
</pre>

<p>
Note that the logging levels are stored separately from the
<code>Log</code> instances themselves.  This is because the log objects
are readonly and stored in the code section.  The log levels must
be in dynamic memory to allow runtime modification.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="naming">Log Naming</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
All logs are identified by a <a href="lang.html#namespaces">qname</a>
(qualified name), which is based on the define field's qname:
</p>

<ol>
<li>If the define field is named "log", then the log qname is
the qname of the declaring type
</li>
<li>If the define field ends in "Log", then the log qname is
the field's qname minus the "Log" suffix
</li>
<li>If none of the above applies, then log's qname is the
field's qname</li>
</ol>

<p>
For example this class in a kit named "acme":
</p>

<pre>
class MyService
{
  define Log log     // log qname is "acme::MyService"
  define Log reqLog  // log qname is "acme::MyService.req"
  define Log stuff   // log qname is "acme::MyService.stuff"
}
</pre>

<p>
By convention, your primary Log definition should be named "log"
to match rule 1.  Sub-logging for extra tracing should use names
with a "Log" suffix.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="logging">Logging</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
To embed logging into your code, call one of following the
<i>logging methods</i>:
</p>

<ul>
<li><code>sys::Log.error</code></li>
<li><code>sys::Log.warning</code></li>
<li><code>sys::Log.message</code></li>
<li><code>sys::Log.trace</code></li>
</ul>

<p>
All of the logging methods take a <code>Str</code> and return an
<code>OutStream</code>, which permits <a href='expr.html#interpolation'>string
interpolation</a>:
</p>

<pre>
// these lines of code
log.message("Started!")
log.error("Cannot open port=$port")
log.trace("Received $numBytes bytes from $addr")

// would print something like
-- MESSAGE [acme::MyServer] Started!
-- ERROR [acme::MyServer] Cannot open port 8080
-- TRACE [acme::MyServer] Received 5 bytes from 32
</pre>

<p>
A few points to note:
</p>

<ul>
<li>Don't add a trailing newline to your message, one will be added automatically</li>
<li>Don't include any severity or log identity in your message string,
this information is automatically included (the actual format is
implementation specific)</li>
<li>You are required to call the logging methods on the field define itself.
For example you can't assign the log reference to a local variable, then
use the local variable to call one of the logging methods - this will
result in a compile time error.  The reason for this restriction is that
it enables the compiler to generate level checking and conditional
compilation checking.</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="runtimeConfig">Runtime Configuration</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Log levels are stored in the <code>Sys.logLevels</code> field.
This array is indexed by <code>Log.id</code> and stores the
current level as a number between 0 and 4 (Log.NONE to Log.TRACE):
</p>

<pre>
// change my logging level to trace
Sys.logLevels[log.id] = Log.TRACE
</pre>

<p>
The current level defines the maximum severity that is
logged.  For example a level or WARNING will log calls
to <code>error</code> and <code>warning</code>, but not
calls to <code>message</code> and <code>trace</code>.  All
log levels default to MESSAGE on startup.
</p>

<p>
The compiler automatically inserts code that jumps over a logging
statement if the current log level is set lower.
This means the method call and any embedded expressions are
efficiently skipped:
</p>

<pre>
// this code
log.trace("This is the ${count++} time")

// is semantically equivalent to
if (log.isTrace())
  log.trace("This is the ${count++} time")
</pre>

<h2>WebService Spy Page</h2>

<p>
If a Sedona device is running the <code>web::WebService</code>, then you
can use the spy page at <code>"&lt;device IP&gt;/spy/logs"</code> to change the
log levels for a SVM at runtime.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="compileTimeConfig">Compile-time Configuration</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
TODO: this feature is not implemented yet
</p>


<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='nativeMethods.html'>Prev</a>
 | <a href='apps.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







