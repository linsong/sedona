<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    21 Jun 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Methods</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='fields.html'>Prev</a>
 | <a href='components.html'>Next</a>
</div>
<h1 class='title'>Methods</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Methods are functions used to implement executable behavior.
The following keywords may be applied to a method declaration:
</p>

<ul>
<li><code>static</code>: class based method versus instance based</li>
<li><code>virtual</code>: indicates method that may be polymorphically overridden</li>
<li><code>abstract</code>: indicates a pure virtual method</li>
<li><code>override</code>: required to indicate an override of an inherited method</li>
<li><code>native</code>: indicates a method implemented in native C code</li>
<li><code>action</code>: promotes a method to a component action</li>
</ul>

<p>
In addition to the keywords above, a method may be annotated with
a <a href='lang.html#protectionScope'>protection scope</a> keyword.
If no protection scope is specified, then <code>public</code>
is assumed.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="return">Return Values</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
If the method returns a value to the calling function, the
return value type is included in the function definition.
If the method does not return anything, the keyword <code>void</code>
is used instead of a return type.
</p>

<pre>
class Example
{
  void echo() { Sys.out.print("echo").nl() }   // returns nothing
  int add(int x, int y) { return x + y }       // returns an int value
}
</pre>

<p>
In Sedona, a method may return any primitive type, or a reference to
any built-in or user-defined class type;
the only exception is an <code>action</code> method, which always returns <code>void</code>.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="static">Static Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Static methods are prefixed with the <code>static</code>
keyword.  Static methods are essentially global functions
scoped within a class name.  They are declared just like
Java methods:
</p>

<pre>
class Example
{
  static void echo() { Sys.out.print("echo").nl() }
  static int add(int x, int y) { return x + y }
}
</pre>

<p>
Static methods are called with an implict or explicit type literal:
</p>

<pre>
Example.echo()       // explicit
int five = add(2, 3) // implicit (only inside Example or subclasses)
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="instance">Instance Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Instance methods are declared whenever the <code>static</code> keyword
is omitted.  Instance methods contain an implicit <code>this</code> parameter,
which is the instance the method is called on:
</p>

<pre>
class Example
{
  int add() { return x + y }
  int sub() { return this.x - this.y }
  int x
  int y
}
</pre>

<p>
Note in the example, that every instance method has an implicit
parameter accessed via the <code>this</code> keyword.  Instance methods
are called with an implict or explicit instance:
</p>

<pre>
add()        // implicit against this
this.sub()   // explicit against this
x.sub()      // explicit against x
x?.sub()     // null safe call
</pre>

<p>
See <a href='expr.html#safeNav'>Safe Navigation</a> for how to use
the "?." operator.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="virtual">Virtual Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Virtual methods are designed to be overridden by a subclass to enable
polymorphism. Methods must be marked using the <code>virtual</code> keyword
before they can be overridden by subclasses. Subclasses must declare
they are overriding a method using the <code>override</code> keyword:
</p>

<pre>
class Animal extends Virtual
{
  virtual void talk() { Sys.out.print("generic\n") }
}

class Cat extends Animal
{
  override void talk() { Sys.out.print("meow\n") }
}

animal.talk()   // prints generic
cat.talk()      // prints meow
</pre>

<p>
By default an overridden method cannot itself be overridden by a subsequent
subclass.  In order for <code>Cat.talk()</code> to be overridden by the subclass
<code>Kitten</code>, it must include again the keyword <code>virtual</code>:
</p>
<pre>
class Cat extends Animal
{
  override virtual void talk() { Sys.out.print("meow\n") }   // override AND virtual
}

class Kitten extends Cat
{
  override void talk() { Sys.out.print("mew!\n") }           // this now compiles
}

kitten.talk()      // prints mew!
</pre>

<p>
Classes that declare virtual methods must derive from <code>sys::Virtual</code>.
Be aware that virtual classes have the overhead of an extra pointer for
their vtable (typically 4 extra bytes).
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="abstract">Abstract Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Abstract methods are virtual methods without an implementation. They
are declared using the <code>abstract</code> keyword. Abstract methods
are implied to be virtual - it is an error to use both the <code>abstract</code>
and <code>virtual</code> keyword. Abstract methods must not provide a
method body.  The containing class must also be declared <code>abstract</code>.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="super">Super</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
By default any virtual method call with an implicit or explicit target
of <code>this</code> invokes the most specific version of that method.
You can use the <code>super</code> keyword to invoke the super class
version of a method:
</p>

<pre>
class Kitten extends Cat
{
  override void talk() { super.talk() }
}

kitten.talk()      // now prints meow

</pre>


<!--/////////////////////////////////////////////////////////-->
<h1 id="ctor">Constructors</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
A class may have one constructor, which is compiled into a method called
<code>_iInit</code>.  Whenever a class declares instance fields with
a <a href='fields.html#defaults'>default value</a>, the compiler auto-generates
a constructor for you.  A class may declare an explicit constructor using
a syntax similiar to Java:
</p>

<pre>
final class BufInStream extends InStream
{
  BufInStream(Buf abuf) { this.buf = abuf }
  Buf buf
}
</pre>

<p>
To keep Sedona lightweight and simple, the following rules apply to 
constructor methods:
<ul>
  <li>A class may only declare one explicit constructor (parameter overloading is not supported). </li>
  <li>A class with an explicit constructor must be marked <code>final</code>. </li>
  <li>Subclasses of <code>sys::Component</code> cannot declare a constructor with parameters.  </li>
  <li>Declared constructors are used with <a href='arrays.html#unsizedClasses'>unsized classes</a> 
  to specify an array length.</li>
</ul>
</p>

<p>
The constructor method for a class is called whenever an object of that type is instantiated.
For static inline fields, this happens as soon as the scode is loaded when the Sedona VM boots up.
For instance inline fields, this happens when the Sedona VM loads the Sedona application and 
calls the constructors for the application's components as well as each component's inline 
object fields.
If the running app is modified remotely, however, any new components will be instantiated
immediately by <code>App.add()</code>, which will call the component's constructor (and all its
non-static inline object fields) at that time.
</p>

<p>
For example:
</p>

<pre>
class Foo
{
  // static constructor calls
  static inline Buf(100) buf
  static inline BufInStream(buf) in
  static inline BufOutStream(buf) out
  static inline Foo inst

  // instance constructor calls
  inline Buf(20) ibuf
}
</pre>

<p>
Inline static fields are initialized in declaration order on VM startup,
which calls the appropriate constructors.  These constructor calls often
result in instance constructor calls, which in turn recursively chain for
nested inline fields.
For the example above, the compiler will create the following code;
<code>Foo._sInit</code> is then automatically called when the VM boots:
</p>

<pre>
static void Foo._sInit()
{
  Foo.buf._iInit(100)
  Foo.in._iInit(Foo.buf)
  Foo.out._iInit(Foo.buf)
  Foo.inst._iInit()
}

void Foo._iInit()
{
  this.ibuf._iInit(20)
}
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="native">Native Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>native</code> keyword is used on methods that are implemented
in C code.  Like abstract methods, native methods must not define
a body.  See <a href='nativeMethods.html'>Native Methods</a> for more details.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="action">Action Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Methods may be annotated with the <code>action</code> keyword
to promote the method into a Component action.  Actions must
be instance methods on a subclass of <code>sys::Component</code>.
See <a href='components.html#actions'>Component Actions</a>
for more details.
</p>


<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='fields.html'>Prev</a>
 | <a href='components.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>
