<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    21 Jun 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Methods</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='fields.html'>Prev</a>
 | <a href='components.html'>Next</a>
</div>
<h1 class='title'>Methods</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Methods are functions used to implement executable behavior.  
The following keywords may be applied to a method declaration:
</p>                                           

<ul>
<li><code>static</code>: class based method versus instance based</li>
<li><code>virtual</code>: indicates method which may be polymorphically overridden</li>      
<li><code>abstract</code>: indicates a pure virtual method</li>      
<li><code>override</code>: required to indicate an override of an inherited method</li>
<li><code>native</code>: indicates a method implemented in native C or Java code</li>      
<li><code>action</code>: promotes a method to a component action</li>      
</ul>

<p>
In addition to the keywords above, a method may be annotated with
a protection scope <a href='lang.html#protectionScope'>keyword</a>.
If no protection scope is specified, then <code>public</code>
is assumed.
</p>      

<!--/////////////////////////////////////////////////////////-->
<h1 id="static">Static Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Static methods are prefixed with the <code>static</code>
keyword.  Static methods are essentially global functions
scoped within a class name.  They are declared just like
Java methods:
</p>

<pre> 
class Example
{
  static void echo() { Sys.out.print("echo").nl() }
  static int add(int x, int y) { return x + y }
}
</pre>   

<p>
Static methods are called with an implict or explicit type literal:
</p>

<pre> 
Example.echo()       // explicit
int five = add(2, 3) // implicit (only inside Example or subclasses)
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="instance">Instance Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Instance methods are declared whenever the <code>static</code> keyword 
is omitted.  Instance methods contain an implicit <code>this</code> parameter 
which is the instance the method is called on:
</p>

<pre> 
class Example
{
  int add() { return x + y }
  int sub() { return this.x - this.y }
  int x
  int y
}
</pre>   

<p>
Note in the example, that every instance method has an implicit 
parameter accessed via the <code>this</code> keyword.  Instance methods 
are called with an implict or explicit instance:
</p>                                   

<pre> 
add()        // implicit against this
this.sub()   // explicit against this
x.sub()      // explicit against x
x?.sub()     // null safe call
</pre>               

<p>
See <a href='expr.html#safeNav'>Safe Navigation</a> for how to use
the "?." operator.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="virtual">Virtual Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Virtual methods are designed to be overridden by a subclass to enable 
polymorphism. Methods must be marked using the <code>virtual</code> keyword 
before they can be overridden by subclasses. Subclasses must declare 
they are overriding a method using the <code>override</code> keyword:
</p>

<pre>
class Animal extends Virtual
{
  virtual void talk() { Sys.out.print("generic\n") }
}

class Cat extends Animal
{
  override void talk() { Sys.out.print("meow\n") }
}

animal.talk()   // prints generic
cat.talk()      // prints meow
</pre>         

<p>
Classes which declare virtual methods must derive from <code>sys::Virtual</code>.
Be aware that virtual classes have the overhead of an extra pointer for
their vtable (typically 4 extra bytes).
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="abstract">Abstract Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Abstract methods are virtual methods without an implementation. They 
are declared using the <code>abstract</code> keyword. Abstract methods 
are implied to be virtual - it is an error to use both the <code>abstract</code>
and <code>virtual</code> keyword. Abstract methods must not provide a 
method body.  The containing class must also be abstract.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="super">Super</h1>
<!--/////////////////////////////////////////////////////////-->

<p>                 
By default any virtual method call with an implicit or explicit target 
of <code>this</code> invokes the most specific version of that method.
You can use the <code>super</code> keyword to invoke the super class
version of a method.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="ctor">Constructors</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
A class may have one constructor which compiles into a method called 
<code>_iInit</code>.  Whenever a class declares instance fields with 
a <a href='fields.html#defaults'>default value</a>, the compiler auto-generates 
a constructor for you.  A class may declare an explicit constructor using 
a syntax similiar to Java:
</p>

<pre>
final class BufInStream extends InStream
{
  BufInStream(Buf buf) { this.buf = buf }
  Buf buf
} 
</pre>

<p>
A class may only declare one explicit constructor (parameter overloading
is not supported by Sedona). A class with an explicit constructor must
be marked <code>final</code>. Subclasses of <code>sys::Component</code> 
cannot declare a constructor with parameters.  Declared constructors are 
used with <a href='arrays.html#unsizedClasses'>unsized classes</a> to 
specify an array length.  
</p>

<p>
All object allocation in Sedona happens through static memory 
management or when a new component is created via <code>App.add</code>.
When allocating a component via <code>App.add</code> the constructor
is called automatically.  All other instances get their constructors
called whenever they are declared as an inline field:
</p>                     

<pre>
class Foo
{        
  // static constructor calls
  static inline Buf(100) buf  
  static inline BufInStream(buf) in
  static inline BufOutStream(buf) out
  static inline Foo inst
  
  // instance constructor calls
  inline Buf(20) ibuf  
}
</pre> 

<p>
Inline static fields are initialized in declaration order on VM startup
which calls constructors.  These constructor calls, will often result in 
instance constructor calls, which in turn recursively chain for nested 
inline fields.  The example above compiles into the following code where 
<code>Foo._sInit</code> is called during VM boot:
</p>

<pre>
static void Foo._sInit()
{
  Foo.buf._iInit(100)
  Foo.in._iInit(Foo.buf)
  Foo.out._iInit(Foo.buf)
  Foo.inst._iInit()
}

void Foo._iInit()
{
  this.ibuf._iInit(20)
}           
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="native">Native Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>     
The <code>native</code> keyword is used on methods which are implemented 
in C and Java code.  Like abstract methods, native methods must not define 
a body.  See <a href='nativeMethods.html'>Native Methods</a> for more details.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="action">Action Methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Methods may be annotated with the <code>action</code> keyword
to promote the method into a Component action.  Actions must
be instance methods on a subclass of <code>sys::Component</code>.  
See <a href='components.html#actions'>Component Actions</a> 
for more details.
</p>


<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='fields.html'>Prev</a>
 | <a href='components.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>
