<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2013 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    05 Mar 2013   Elizabeth McKenney   Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Sedona Device Simulator</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='platTutorial.html'>Prev</a>
 | <a href='platCertified.html'>Next</a>
</div>
<h1 class='title'>Sedona Device Simulator</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<p>
A <i>Sedona Device Simulator</i> allows an app designed for a specific Sedona platform 
to run on another platform. 
The Simulator consists of a simulator Sedona VM plus a special scode file and 
platform manifest that allow the app to run as if it were on the original device. 
</p>
<p>
In a simulator Sedona VM, the native methods for the original platform are replaced with 
functions compatible with the simulator platform. 
The new functions may supply functionality equivalent to the originals, or they may be stubs, 
depending on how the simulator SVM is built. The degree to which a given Device Simulator 
will mimic the actual device is largely a function of the effort level put into creating it.
</p>

<ul><li>
<b>Example</b>: 
The native code for <code>DigitalIo.gpioGet()</code> 
in the SVM for a specific hardware platform 
reads an actual GPIO input on the device.
In a <i>simulator</i> SVM designed to run apps for that platform on Windows, 
the <code>DigitalIo.gpioGet()</code> native table entry might simply point to 
a stub function that always returns 0.
Or, it may point instead to an implementation that returns a calculated value
that simulates a particular behavior.
In either case the native function pointer is valid, and an app designed to run on the
original platform should also run successfully on the simulator SVM.
</li></ul>


<p>
The Sedona compiler <code>sedonac</code> provides some functionality to aid in the 
creation of a simulator SVM. 
In particular, it can automatically create empty stub functions for 
any native methods that have not already been supplied by the developer. 
These source stubs can then be edited to add the desired functionality, 
or can simply be left as-is to create a limited (but usable) simulator SVM. 
</p>
<br/>

<!--/////////////////////////////////////////////////////////-->
<h1>Creating a device simulator SVM for your platform</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The following instructions will help you create a Sedona device simulator
SVM for your own device. 
(It is usually convenient to bundle these operations into a script that can be run as needed.)
</p>

<ol>
  <li><a href="#step1">Step 1</a>: Create a platform XML file for the simulator SVM</li>
  <li><a href="#step2">Step 2</a>: Stage the Device Simulator SVM source files</li>
  <li><a href="#step3">Step 3</a>: Build the simulator SVM</li>
  <li><a href="#step4">Step 4</a>: Build scode for the Device Simulator</li>
  <li><a href="#step5">Step 5</a>: Include an app for the Device Simulator</li>
  <li><a href="#step6">Step 6</a>: Package and install the Device Simulator</li>
  <li><a href="#step7">Step 7</a>: Run the Device Simulator</li>
</ol>

<br/>
<!--/////////////////////////////////////////////////////////-->
<h1 id="step1">Step 1: Create a platform XML file for the simulator SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The first step in creating a Device Simulator is setting up a simulator version 
of the platform XML file. By convention, the new file should have the same name 
as the original, with "-sim" inserted just before the extension.
</p>

<ul><li>
  <b>Example</b>: the simulator version of <code>generic-unix.xml</code> would be <code>generic-unix-sim.xml</code>. 
</li></ul>

<h2> Platform ID </h2>

<p>
Inside the new XML file, the platform ID should be modified in the same way as the filename.
</p>

<ul><li>
  <b>Example</b>: <code>generic-unix-sim-${sedona.env.version}</code> 
</li></ul>

<h2> Simulator platform compile attributes </h2>

<p>
Next, the attributes of the <code>&lt;compile&gt;</code> tag should modified to match the simulator 
platform rather than the original target platform.
</p>

<ul><li>
<b>Example</b>: For a Device Simulator that will run on Windows, 
set <code>endian="little"</code> and <code>blockSize="4"</code>. 
</li></ul>

<h2> Native kits </h2>

<p>
The list of <code>&lt;nativeKit&gt;</code> tags requires no modification. 
</p>

<h2> Native source paths </h2>

<p>
The list of <code>&lt;nativeSource&gt;</code> tags must be modified to reflect the location 
of the native method implementations for the simulator platform. 
If any native methods are not supplied in the paths provided here, 
sedonac will create empty stubs for them at staging time. 
This is also where any simulator-specific native method implementations will 
be included - just provide the path to the desired source code 
in a <code>&lt;nativeSource&gt;</code> tag like the others.
</p>

<ul><li>
  <b>Example</b>: to create a Device Simulator to simulate a unix platform on 
  Windows, modify the <code>&lt;nativeSource&gt;</code> tags as follows:

<pre>
    &lt;nativeSource path="/src/sys/native/unix" /&gt;
    &lt;nativeSource path="/platforms/src/generic/unix/native" /&gt;
</pre>

should become

<pre>
    &lt;nativeSource path="/src/sys/native/win32" /&gt;
    &lt;nativeSource path="/platforms/src/generic/win32/native" /&gt;
</pre>
</li></ul>

<p>
If there is a native method for the original platform that <b>must</b> return a 
specific value (or must <b>not</b> return 0), the developer can provide source code 
for a substitute that returns the desired value. The native source code file 
containing the substitute can be stored anywhere, as long as there is a 
<code>&lt;nativeSource&gt;</code> tag in the sim platform XML file that points to its location.
</p>

<p>
At the other end of the simplicity spectrum, it is also possible to develop 
a more elaborate Device Simulator. For example one could provide a graphical 
representation for digital outputs on the simulator platform. The native code 
that generates the graphics, as well as the native method implementations that 
control them, would similarly be located and staged via one or more 
<code>&lt;nativeSource&gt;</code> tags. 
</p>

<ul style="list-style-type:none">
  <li style="padding:5px;border:solid 1px #c9612a;">
<b>Tip</b>:
If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, 
native source must be provided for whatever methods the simulated platform uses 
to populate the <code>platformId</code>, <code>platformVer</code>, 
and <code>memAvailable</code> slots. 
These slots are often used by provisioning tools, and must have valid values 
for the tools to work. 
(Beginning with 1.2, there are native methods of <code>sys::PlatformService</code> 
so that <code>sedonac</code> can provide them automatically.  
Pre-1.2 however, they were unique to each platform.)
</li></ul>

<br/>

<h2> Native patches </h2>

<p>
Any native patches required for the Simulator SVM need to be accounted 
for in <code>&lt;nativePatch&gt;</code> tags. 
Note: The set of patches for the Device 
Simulator SVM may not be the same as the set for the original platform. 
In fact, since native patches are generally created only for SVMs that 
cannot be rebuilt easily, it is unlikely any will be needed in a simulator SVM. 
</p>

<h2> Manifest includes </h2>

<p>
If the platform definition file uses the <code>&lt;manifestInclude&gt;</code> tag, 
the developer should judiciously consider whether it can remain as-is or 
needs to be modified for the simulator SVM. In particular, depending 
on how (or if) the original platform supports the Manifest Server feature 
then it may need to be omitted or re-implemented for the simulator. 
</p>

<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step2">Step 2: Stage the Device Simulator SVM source files</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
When the platform XML file for the simulator SVM is complete, 
run <code>sedonac</code> on the new file using the option <code>-stageSim</code>. 
Specify the location to be used for the staging area via the <code>-outDir</code> option.
</p>

<ul> <li>
  <b>Example</b>: <code>sedonac -stageSim -outDir temp generic-unix-sim.xml</code>
</li></ul>

<p>
Sedonac will collect the files from all the <code>&lt;nativeSource&gt;</code> paths and 
store them in the staging area, and then scan the source code to identify 
any missing native method implementations. 
It will then create empty stubs for the missing methods. 
It will also create a <code>.par</code> folder in the staging directory to hold the 
platform archive (generated later), and create the platform manifest file 
for the simulator platform.
</p>

<ul> <li>
  <b>Example</b>: After running the above command, the directory <code>temp</code> 
  has the following contents:

<pre>
win32&gt; ls -A temp

.par/                             inet_util_std.c                         sys_FileStore_std.c
datetimeStd_DateTimeServiceStd.c  inet_util_std.h                         sys_File_std.c
errorcodes.h                      main.c                                  sys_StdOutStream_std.c
inet_Crypto_sha1.c                nativetable.c                           sys_Str.c
inet_TcpServerSocket_std.c        platUnix_native_stubs.c                 sys_Sys.c
inet_TcpSocket_std.c              platWin32_Win32PlatformService_win32.c  sys_Sys_std.c
inet_UdpSocket_std.c              scode.h                                 sys_Sys_win32.c
inet_sha1.c                       sedona.h                                sys_Test.c
inet_sha1.h                       sedonaPlatform.h                        sys_Type.c
inet_util.h                       sys_Component.c                         vm.c
</pre>

  And the subfolder <code>.par</code> contains:

<pre>
win32&gt;ls -A temp/.par

platformManifest.xml  svm/
</pre>

</li></ul>

<p>
At this time, the source code for the Simulator's SVM is ready for building. 
If desired, any stub functions created by sedonac may be edited now to add functionality. 
</p>


<ul style="list-style-type:none">
  <li style="padding:5px;border:solid 1px #c9612a;">
<b>Tip</b>:
If you are creating a device simulator for a device running Sedona 1.0 / TXS 1.1, 
you will need to use <code>sedonac.exe</code> and <code>sedonac.jar</code> 
from a 1.2 installation for this step,
since the pre-1.2 versions do not have the simulator feature.
</li></ul>

<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step3">Step 3: Build the simulator SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The next step is to compile the source code into an SVM executable. 
Use any toolchain that is appropriate for the <b>simulator</b> platform. 
When the executable has been created, copy it into the <code>.par/svm</code> 
folder inside the staging folder.
</p>

<br/>
<!--/////////////////////////////////////////////////////////-->
<h1 id="step4">Step 4: Build scode for the Device Simulator</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Device Simulator requires a specially built scode file, 
so that the scode will run on the simulator platform. 
To do this, simply copy a basic scode XML file (such as one that 
is normally used for building scode for the original platform) 
and change the platform-specific parameters in the 
<code>&lt;sedonaCode&gt;</code> tag to match the <b>simulator</b> platform. 
This is the same as what was done earlier for the platform definition XML, 
e.g. to run on Windows set <code>endian="little"</code> and <code>blockSize="4"</code>. 
The list of kits requires no modifications.
</p>

<p>
Run <code>sedonac</code> on the new scode file, and place it in <code>.par/svm</code> 
with the SVM executable.  (Name it <code>kits.scode</code> for later convenience.) 
</p>

<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step5">Step 5: Include an app for the Device Simulator</h1>
<!--/////////////////////////////////////////////////////////-->
<p>
Finally, find or create a basic app with a schema that matches the scode built
in the previous step. 
It does not require any modification. Simply build it and place the <code>.sab</code>
file into <code>.par/svm</code> with the SVM and scode files. 
(Name it <code>app.sab</code> for later convenience.) 
</p>

<br/>
<!--/////////////////////////////////////////////////////////-->
<h1 id="step6">Step 6: Package and install the Device Simulator</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Install the simulator platform into the platform database 
using the <code>platArchive</code> tool, as follows: <br/>
<code> platArchive --stage [path to .par folder] --svm --db </code>
</p>


<ul> <li>
  <b>Example</b>: <code>platArchive --stage temp/.par --svm --db</code>
</li></ul>

  <p>
  This will also package the <code>.par</code> folder into a zip archive 
  (in this example, the archive would be named <code>tridium-generic-unix-sim-1.2.2.par</code>), 
  which is a convenient way to distribute the Device Simulator with its associated files. 
</p>

<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step7">Step 7: Run the Device Simulator</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
To run the simulator SVM from the command line, simply navigate to the <code>svm/</code>
folder on the simulator host and run the SVM executable, e.g. 
</p>

<pre>
svm&gt;svm --plat kits.scode app.sab

Sedona VM 2.1.28-sim
buildDate: Jan 14 2013 10:01:34
endian:    little
blockSize: 4
refSize:   4

Running SVM in Platform Mode
-- MESSAGE [sys::App] starting
-- MESSAGE [sox::SoxService] started port=1876
-- MESSAGE [sox::SoxService] DASP Discovery enabled
-- MESSAGE [sys::App] running
</pre>

<p>
Make sure you are running the SVM executable in the <code>svm/</code> folder, 
and not the one in <code>{Sedona home}/bin</code>.  (You may need to modify your
path variable to pick up the current directory first.)
</p>

<p>
The simulator SVM is now running on the simulator host.  It is a real Sedona VM
and can be discovered and connected to by any Sox client on the same network.
Any Sedona app that was designed to run on the original hardware platform
should run successfully on this SVM as well.  The main difference is that any
native methods that are stubbed out in the simulator SVM will offer only their
stubbed behavior to the app. The simulator SVM will be as realistic as the
implementations of its native methods will allow.
</p>

<p>
<b>Note</b>: The <code>svm/</code> folder is probably <i>not</i> the best location 
for running the simulator SVM, since it is likely just a temporary directory.  
This example is just a way to demonstrate the simulator SVM functionality.
</p>

<br/> <br/>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='platTutorial.html'>Prev</a>
 | <a href='platCertified.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







