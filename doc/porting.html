<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    30 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Porting</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='testing.html'>Prev</a>
 | <a href='niagara.html'>Next</a>
</div>
<h1 class='title'>Porting</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="override">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The SVM is designed to be easily ported to new hardware and
OS platforms using the following steps:
</p>

<ol>
<li>Add platform specific declarations to <code>sedona.h</code></li>
<li>Select the kits with native methods that you plan to support</li>
<li>Write custom implementations for native methods where needed</li>
<li>Write bootstrap code to start the SVM</li>
<li>Stage the VM code and platform manifest using an XML build script</li>
<li>Compile the C code using your platform's C compiler</li>
<li>Run the test suite to verify a successful port</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sedonaH">sedona.h</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Porting to a new target platform begins with <code>sedona.h</code>
which is located in the <code>src/vm</code> directory.  This file is included by
every native source file, and contains essential definitions required
for building the native layer.
It contains sections for major target
platforms such as Win32, QNX, and UNIX.  Each platform's section is
wrapped by an <code>#if defined()</code> directive for the
given target compiler/platform.  If none of the existing sections is
matched, the preprocessor will look for a file named <code>sedona-local.h</code> in
the include path, and include its contents in place of the other target
sections.
</p>

<p>
Definitions for a new platform can be added in a new
<code>#elif defined()</code> section in <code>sedona.h</code>, 
but the modified <code>sedona.h</code>
will then need to be updated manually if any changes are made to the public
version of the file.  A simpler solution is to create a local <code>sedona-local.h</code>
file to hold the definitions for the new platform.  This file will then automatically
be included in the build and can be maintained separately from the core Sedona Framework
distribution.
</p>

<p>
There are instructions at the top of <code>sedona.h</code> that describe
the types and macros that must be defined for each platform, such as
the ANSI C 99 integer types and macros for endianness and block sizes.
Definitions for key types like <code>Cell</code> and
<code>SedonaVM</code> are defined at the bottom of the file,
as well as the function declarations for working with the VM.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="natives">Natives</h1>
<!--/////////////////////////////////////////////////////////-->


<p>
Kits without native methods require no changes to run on a new target platform.
For each kit with native methods, the existing code must first be examined to
see what additional work needs to be done.
</p>

<p>
As described in the <a href="nativeMethods.html">Native Methods</a> chapter,
every native method must have an appropriately-named C function
that implements that method for the target platform.
However some C functions are more portable across platforms than others.
For example a native method like <code>sys::Sys.copy</code> may be written
in ANSI C and shared by many or perhaps all platforms.
Other methods, such as <code>sys::Sys.ticks</code>, almost always require a
custom implementation for each hardware or OS platform.
</p>

<p>
All the native source code is organized under a directory called <code>native</code> in
the kit directory.  Native functions that are portable
across <i>all</i> platforms should be contained in C files
located directly in the <code>native</code> directory, one file per class
using the naming convention "<i>{kit}_{class}.c</i>".
Any native functions that are implemented separately for each platform
should be located in sub-directories under <code>native</code>, one per platform.
Code files under these directories are named using the convention
"<i>{kit}_{type}_{platform}.c</i>".  This helps avoid file name collisions.
</p>


<p>
For example, given a kit <code>myKit</code> with one class <code>MyClass</code> 
that has native functions,
some portable and some platform-specific, the code would be organized as follows:
</p>
<pre id="dirStruct">
myKit/
  +- kit.xml
  +- MyClass.sedona
  +- native/
  |    +- myKit_MyClass.c
  |    +- qnx/
  |    |    +- myKit_MyClass_qnx.c
  |    +- win32/
  |    |    +- myKit_MyClass_win32.c
  +- test/
  |    +- MyClassTest.sedona
</pre>

<p>
All the source code files for the native methods are stored under the folder 
<code>myKit/native</code>.
Functions that can be shared across all platforms are in the file named
<code>myKit_MyClass.c</code>, located in the <code>native</code> folder.  
These functions should not need to
be implemented again when porting to a new platform.
</p>
<p>
Source files for platform-specific implementations are located in a separate subfolder
for each platform, and the platform name is appended to the source file name.
When porting the kit to a new platform <code>newPlat</code>, 
simply create a new folder <code>native/newPlat</code>
and put the native method implementations into a source file 
<code>myKit_MyClass_newPlat.c</code> under the new folder.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="bootstrap">Bootstrap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
In addition to the native methods for each kit, the new platform port will need
some native bootstrapping code to start the SVM.  For sophisticated devices
with an OS and a file system (such as a PC), it may be sufficient to build and run
the code provided in <code>main.c</code>, which is located in the <code>src/vm</code> 
directory.  This function can
be executed from the OS command line, providing on the command line the filenames for 
the scode image and the app to be run.  (Even with platforms that cannot support
<code>main.c</code>, it may still be useful as a guide for writing the new bootstrap code.)
</p>

<p>
On smaller, simpler platforms, new bootstrap code will need to be written.
Every platform will have a unique implementation, but at some point the SVM
will need to be started by calling <code>vmRun(SedonaVM*)</code>.
(Both <code>vmRun</code> and the <code>SedonaVM</code> struct are defined in <code>sedona.h</code>.)
Before calling <code>vmRun</code>, a SedonaVM struct must be created and then initialized as
follows:
</p>


<ol>
<li>Configure <code>codeBaseAddr</code> and <code>codeSize</code>
to point to the scode image.  Typically the scode is stored in a disk file
or in flash memory, and loaded into RAM at this point.  If so then <code>codeBaseAddr</code>
is simply a pointer to the scode image in RAM.
</li>

<li>Configure <code>stackBaseAddr</code> and <code>stackMaxSize</code>
to point to an area of RAM that can be used for the stack.
Most commonly this is a static or dynamically-allocated array of the desired size.
</li>

<li>Configure <code>args</code> and <code>argsLen</code>
to pass in the arguments to the Sedona Framework main method.  The <code>args</code>
pointer should reference a normal array of C null terminated strings (just
like a standard C main signature).
</li>

<li>Configure a callback function for <code>onAssertFailure</code>.
This function is generally used in test code, and is called whenever an assert
condition fails.   More details on using the Sedona Framework test facility
may be found in the <a href="testing.html">Test</a> chapter.
</li>

<li>Configure the <code>call</code> function pointer to point to <code>vmCall</code>.
This indirection provides a hook for patching a ROM based VM.
</li>

<li>Configure a pointer to the <code>nativeTable</code> array generated
automatically during the VM code generation stage.  See the
<a href="nativeMethods.html">Native Methods</a> chapter for more information.
</li>
</ol>

<p>When the <code>SedonaVM</code> struct has been initialized, start the SVM
by calling the <code>vmRun()</code> function and passing a pointer to the struct.
If <code>vmRun</code> returns a non-zero value (other than <code>ERR_HIBERNATE</code>
or <code>ERR_YIELD</code>, discussed below), then there is a problem.  
Errors in the scode image or the app will generally produce an error code defined 
in <code>src/sys/Err.sedona</code>; errors in the VM itself are usually indicated 
by an error code in <code>src/vm/errorcodes.h</code>.
</p>

<p>Some platforms may require the Sedona VM to yield execution control to allow other 
tasks to run.  When <code>vmRun()</code> returns <code>ERR_YIELD</code>, the application is
yielding CPU control.
See the <a href='apps.html#yield'>Yield</a> section for more details.
</p>

<p>Each platform requires the implmentation of an appropriate hibernation strategy.
When <code>vmRun()</code> returns <code>ERR_HIBERNATE</code> then the application
has requested that the platform go into a low-power or sleep state.  Awakening from
this state is under the control of the device, not the Sedona Framework application.
Upon awaking, call the <code>vmResume()</code> function to start the SVM
again from where it left off.
See the <a href='apps.html#hibernation'>Hibernation</a> section for
more details.
</p>

<p>If the VM exits normally, the global variables <code>assertSuccesses</code>
and <code>assertFailures</code> will contain the number of calls
to <code>assert</code> that passed and failed, respectively.
</p>



<!--/////////////////////////////////////////////////////////-->
<h1 id="staging">Staging</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Once the native code has been implemented, the next step is to <i>stage</i>
the VM and native code. This copies the relevant native source files into a
single directory in order to compile them using the appropriate native
toolchain.</p>

<p>Staging is accomplished by running <code>sedonac</code> with a
<a href="platDef.html#definition">platform definition</a> file and specifying
the output directory for the staged files. The platform definition lists all the
directories containing C source files required to build the SVM for a
target platform. (The platform toolchain may add additional non-Sedona files
when it builds the final executable). See the <a href="platDef.html">platform definition</a>
section for more details and an example platform definition file.
</p>

<p>
The platform definition file supplies some basic information about the platform,
then lists the kits with native code that will be supported by the VM.
Kits without native methods do not need to be mentioned in the platform XML.
Finally it identifies the path to each directory containing native code that
will be required by the VM at runtime.  This includes not only the relevant
Sedona native methods implementations, but also the source for the SVM itself.
(On platforms where some portion of the VM is in ROM, only the RAM-based
code may need to be included here.)
</p>

<p>
Staging is performed by calling <code>sedonac</code> with the platform definition file,
specifying the target directory via the <code>-outDir</code> option.  For example,</p>
<pre>sedonac platforms/src/acme/basicPlatform-win32.xml -outDir tempStageDir
</pre>

<p>
This results in the following:
</p>

<ul>
  <li>All existing files are removed from the folder <code>tempStageDir</code>
  </li>

  <li>All source files are copied from the listed paths into <code>tempStageDir</code>
  </li>

  <li>The file <code>nativetable.c</code> is generated, which defines the native
  function <a href="nativeMethods.html#tables">lookup table</a>
  </li>

  <li>If the platform id is known at staging time, a <code>sedonaPlatform.h</code>
  file is created, which contains the <code>PLATFORM_ID</code> macro.
  </li>

  <li>The <a href="platDef.html#manifest">platform manifest</a> is staged
  in <code>tempStageDir/.par/platformManifest.xml</code>. The toolchain can later
  add the SVM binary to into the <code>.par/svm/</code> directory (if desired) and then
  generate a <a href="par.html">PAR file</a>. The PAR file could be
  uploaded to <a href="http://sedonadev.org">sedonadev.org</a> or installed in the
  local <a href="par.html#db">platform database</a>.
  </li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="wrapUp">Wrap Up</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Note that <code>sedonac</code> does not build the C code, it simply assembles the files
together into a single directory.  The C code must then be built with the appropriate
toolchain for the target platform.
</p>

<p>Neither does <code>sedonac</code> generate an actual PAR file for you.  It
will help by staging a basic <code>.par/</code> directory containing the
platform manifest. However, the toolchain build process will need to include
steps/scripts to generate the PAR file for local and/or public use.
</p>

<p>
Once the VM executable has been built, a good next step is to run the
<a href="testing.html">test harness</a> and verify the port was successful.
</p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='testing.html'>Prev</a>
 | <a href='niagara.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>
