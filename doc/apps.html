<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    12 Sep 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Apps</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='logging.html'>Prev</a>
 | <a href='security.html'>Next</a>
</div>
<h1 class='title'>Apps</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Applications for the Sedona Framework are designed and deployed according to
the component model, which separates the code from the application.
In this architecture you have a clean boundary between the code packaged into 
kits and the application defined as a tree of components defined in those kits.
This model allows you to build applications simply by assembling
components, configuring their properties, and linking slots
together to define control flow.  This style of programming is especially
amenable to graphical programming.
</p>

<p>
So when we refer to a Sedona Framework application, we are really talking
about a tree of components assembled together.  An application is
purely declarative, all the code is encapsulated in the kits.  The
application itself is stored as a file using one of two file formats:
</p>

<ul>
<li><b>SAX</b>: a simple XML representation
of the application that is easily generated and consumed by software tools</li>
<li><b>SAB</b>: a compact binary representation
of the application, suitable for storage and execution on a Sedona Framework-enabled
device</li>
</ul>

<p>
You can convert between the two file formats using
<a href='sedonac.html#compileApp'>sedonac</a>.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="bootstrap">Boot Strap</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Applications are boot-strapped in the following phases:
</p>

<ol>
<li><b>Loaded</b>: Each component is loaded from the SAB file into
memory and its <code>Component.loaded()</code> callback is invoked.</li>
<li><b>Start</b>: Once all the components are loaded, each component 
has its <code>Component.start()</code> callback invoked.</li>
<li><b>Running</b>: The application enters the main execution loop 
(described next).</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="execution">Execution</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The Sedona Framework's execution model is based a single-threaded main loop
with a fixed scan rate:
</p>

<ol>
<li>Recursively execute components.  For each component:
  <ol type='a'>
  <li>Step through the component's list of children and execute them first</li>
  <li>Propagate incoming links to this component</li>
  <li>Call this component's <code>execute()</code> virtual method</li>
  </ol>
</li>
<li>Give any remaining time in the scan cycle to services via
<code>Service.work()</code></li>
<li>If no services have remaining work, then relinquish CPU (via yield or sleep) until next cycle</li>
</ol>

<h2 id="multirate">Controlling child execution rate</h2>
<p>
For Sedona 1.2 a new virtual method was added to the <code>Component</code> class.
If a component's <code>allowChildExecute()</code> returns <code>false</code>, then the
app will skip (1a), the recursive step through the component's child components.  
It will simply call <code>execute()</code> on the current component and then go on to 
the next one at the same hierarchy level.  
(The base class version of the method always returns
<code>true</code>, which preserves pre-1.2 behavior.)
This method can be overridden to force child components to be executed at a slower
rate than the main loop.  As an example, there is a new component <code>sys::RateFolder</code> 
that uses this strategy to provide multi-rate app functionality.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="yieldSleep">Yield vs Sleep</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Depending on the underlying execution environment, the App can either
return control to the OS (exit the SVM) or sleep until it's time to run again.
</p>
<h2>Preemptive multithreaded OS</h2>
<p>
  These include Windows, Linux or QNX.  When a thread calls the OS sleep
  primitive, other threads are given a chance to run.  The SVM thread may be
  swapped in and out several times during an execute cycle.
</p>
<h2>Main Loop</h2>
<p>
  In this environment, the Sedona VM executes as the main loop and
  all other work is done at ISR level.  Once the App completes an
  execute cycle, it can delay by entering a busy-wait loop.
</p>
<h2>Cooperative tasking OS </h2>
<p>
In this environment, a task must return control to the scheduler to allow other tasks a 
chance to run.  The sleep and busy-wait approaches won't work here since the SVM will never 
exit, so the SVM must support a clean exit and re-entry. This is accomplished by the <i>yield</i>
mechanism described below.
</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="yield">Yield</h1>
<!--/////////////////////////////////////////////////////////-->
<p>
  The Sedona Framework supports <i>yielding</i> to provide a graceful exit (and
  subsequent reentry) of the SVM, allowing the platform CPU to perform other operations.
</p>
<p>
  Systems that require yield functionality must override the following
  methods of <code>PlatformService</code>:
</p>

<ul>
  <li><code>yieldRequired()</code> - returns true if the SVM should exit after each App 
  execute cycle</li>
  <li><code>yield(long yieldTime)</code> - indicates the SVM will be exiting and requests to 
  be resumed in yieldTime nanoseconds</li>
</ul>

<p>
If a PlatformService subclass returns true to yieldRequired(), then the App will exit with
the error code <code>ERR_YIELD</code> after each execution loop.  
On exiting, the App will call <code>yield(yieldTime)</code> to determine how soon
it needs to be resumed.
</p>

<p>
Native code should resume the SVM via <code>vmResume(SedonaVM*)</code> as soon as possible,
but before the requested time.  If vmResume is not called before yieldTime expires, App cycle
overruns could occur.
</p>



<!--/////////////////////////////////////////////////////////-->
<h1 id="hibernation">Hibernation</h1>
<!--/////////////////////////////////////////////////////////-->
<p>
When entering hibernation, the App exits and returns control to the bootstrap code.
It is similar to yield but it is expected that the hibernation time will be much longer
than a typical yield time.  Hibernation is driven by application logic and most likely
will not occur each App execute cycle, whereas yield must occur each cycle.
</p>

<p>
To enter the hibernation state, an application calls <code>App.hibernate()</code>.
This will set a flag on App and when the current execution cycle is complete,
it will cause the App to exit with error code <code>ERR_HIBERNATE</code>.
This will gracefully unwind the call stack, returning control to the boot code.
The device's boot code should then put the device to sleep.  It is a device dependent
issue to decide how it will wake up from hibernation.  When the device does wake, it
should restart the SVM with a call to <code>vmResume(SedonaVM*)</code>.  If your device
doesn't support hibernation, then you will need to simulate it using code such
as the following:
</p>

<pre>
result = vmRun(&amp;vm);
while (result == ERR_HIBERNATE)
{
  //printf("-- Simulated hibernate --\n");
  result = vmResume(&amp;vm);
}
</pre>

<p>
If you are developing Sedona Framework components, applications, or drivers you should
keep hibernation in mind. Any software that might run on a battery powered
device needs to support hibernation cleanly. This means that function blocks
should assume the scan rate might have hibernation pauses. If you have
services that need to do something special when hibernating or waking, then
you will need to override the functions
<code>Service.onHibernate()</code> and <code>Service.onUnhibernate()</code>.
<code>Service.onHibernate()</code> will be called prior to SVM exit.  <code>Service.onUnhibernate()</code> will be called after the SVM is resumed and prior to the App execution loop starting back up.

</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="steadystate">Steady State</h1>
<!--/////////// move this after Execution? //////////////////-->

<p>
Most apps will be fully operational by the end of the first cycle.
When hardware I/O is involved, however, an app may need to allow additional time for the
hardware to warm up, or for complex logic results to propagate fully to all components.
For this purpose, the Sedona Framework provides a "steady state" timing feature that should be used
to protect the hardware from reading or writing transient values while the app is
starting up.
</p>

<p>
The steady state feature consists of two pieces:
</p>

<ul>
  <li><b>timeToSteadyState</b>:
  This integer specifies the time delay between the start of app execution and the time at
  which the app is assumed to be in "steady state".
  It is a config property of the App class, so it can be set in the app definition (.sax file) or
  at runtime from a remote access tool (e.g. the App property sheet in Sedona Framework Workbench).
  <br/> <br/>
  The default value is 0, meaning that the delay ends when the app enters the "Running"
  phase described above.  The correct value for a given App will vary depending on
  the application logic and the specific hardware involved.
  </li>
  <br/>
  <li><b>isSteadyState()</b>:
  This is a method that returns <code>true</code> if the app has entered
  "steady state" mode, i.e. if the time delay defined by <code>timeToSteadyState</code>
  has elapsed, and <code>false</code> otherwise.  Once steady state mode is reached,
  this method will continue to return <code>true</code> until the app is restarted.
  Code that affects hardware on the native level should use this method to
  avoid reading or writing hardware values until steady state is reached.
  </li>
</ul>

<p>
<b>Note</b>: This feature is not used internally within the App.
It only affects behavior of components that use the <code>isSteadyState()</code> method.
It is the responsibility of each kit developer to call this method as needed to protect the
hardware.
</p>
By default, <code>App.timeToSteadyState</code> applies only to the first time the SVM is started.  
Once steady time has elapsed, hibernate/yield will not affect it.  
If <code>App.hibernationResetsSteadyState</code> is set to true, then the steady state flag will 
be cleared each time device exits hibernation.


<!--/////////////////////////////////////////////////////////-->
<h1 id="links">Links</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Links are the mechanism used to define control flow in an app.
Links are said to be <i>from</i> a given component's slot <i>to</i>
another component's slot.
</p>

<p>
Currently links are supported only between properties; you cannot
link to an action slot.  
During link propagation, the <i>from-property</i> value is copied into
the <i>to-property</i>.  This mechanism could be used, for example, to link
sensor inputs through control logic to control actuator outputs.
</p>
<br/>
<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="services">Services</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Services are special components that subclass from
<a href='sys/Service.html'>sys::Service</a>.  Services have
three primary characteristics that set them apart from other
types of components:
</p>

<ul>
<li><b>Type Lookup</b>: Services are easy to lookup by
type via the <code>App.lookupService</code> method.  This allows other
components in the App to find a given service at runtime simply by 
knowing its type.
</li>
<li><b>Background work</b>: Other components get a single
callback, <code>execute()</code>, to do work during a scan cycle.  
Service components, on the other hand, have an additional callback,
<code>work()</code> to handle background work during any time available at
the end of a given scan cycle.
</li>
<li><b>Hibernation control</b>: Each time the App finishes an execute
  cycle, it calls <code>Service.canHibernate()</code> on all services.
  If a service is not in a state where it can hibernate, it should
  return false.
  (For example, if a service is waiting for a network reply, it would return false.)
  <a href='platTutorial.html'>Platform services</a> 
  for devices that never need to hibernate should always return false.
</li>
</ul>

<p>
Services are often used to provide functionality to other components.
For example the <code>UserService</code> is used to lookup and
authenticate user accounts.  Many services such as protocol drivers
also perform background work to service network messages.
</p>
<br/>
<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sax">SAX File Format</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
A SAX file is structured as follows:
</p>

<pre>
&lt;sedonaApp&gt;
&lt;schema&gt;
  &lt;kit name='sys'/&gt;
  ...
&lt;/schema&gt;
&lt;app&gt;
  &lt;comp name="play" id="1" type="sys::Folder"&gt;
    &lt;comp name="rampA" id="7" type="control::Ramp"&gt;
      &lt;prop name="min" val="20.00000"/&gt;
      &lt;prop name="max" val="80.00000"/&gt;
    &lt;/comp&gt;
    ...
  &lt;/comp&gt;
  ...
&lt;/app&gt;
&lt;links&gt;
  &lt;link from="/play/rampA.out" to="/play/something.else"/&gt;
  ...
&lt;/links&gt;
&lt;/sedonaApp&gt;
</pre>

<p>
<b>&lt;sedonaApp></b> root element that contains:
</p>
<ul>
<li><b>&lt;schema></b>: contains <b>&lt;kit></b> elements</li>
<li><b>&lt;app></b>: contains <b>&lt;comp></b> elements</li>
<li><b>&lt;links></b>: contains <b>&lt;link></b> elements</li>
</ul>

<p>
<b>&lt;kit></b> defines the kits used by the application:
</p>
<ul>
<li><b>name</b>: required kit name</li>
<li><b>checksum</b>: optional kit checksum; if omitted the latest
version of the kit is assumed</li>
</ul>

<p>
<b>&lt;comp></b> defines each component in the application:
</p>
<ul>
<li><b>&lt;comp></b>: nested elements map to nested components</li>
<li><b>&lt;prop></b>: property configuration for the component</li>
<li><b>name</b>: required name of component (limited in length)</li>
<li><b>type</b>: required qname of the component's type</li>
<li><b>id</b>: optional two byte identifier; if omitted an id is auto-generated</li>
</ul>

<p>
<b>&lt;prop></b> defines the property value of a component
within a <b>&lt;comp></b> element.  Supported attributes:
</p>
<ul>
<li><b>name</b>: required name of property</li>
<li><b>val</b>: required value.  Buf properties should be a base64
encoded value (unless asStr in which case just use string value).</li>
</ul>

<p>
<b>&lt;link></b> element defines a link between two slots using
the format of "/path/comp.slot":
</p>
<ul>
<li><b>from</b>: the from component and slot name</li>
<li><b>to</b>: the to component and slot name</li>
</ul>

<!--/////////////////////////////////////////////////////////-->
<h1 id="sab">SAB Files</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
While XML is a nice representation for tools to work with
app files, XML is too big and difficult to work with in an
embedded device.  So we use the SAB format when we need a compact
binary representation.  Sedona Framework devices typically store their
application as an SAB file (although often it might just be a location 
in flash memory versus a real file system).
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="appschema">Schemas</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona Framework application files, whether stored as SAX or SAB format,
always contain a <a href='schema.html'>schema</a>.  
This is simply a list of the kits (with matching kit checksums) that the 
app requires in order to run.
The Sedona VM cannot start the app if its current scode image does not contain
all the kits in the app's schema.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="apis">APIs</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
If you want to develop tools for managing Sedona apps, 
check out the <code>sedona.offline</code> Java APIs for working
with both SAX and SAB files:
</p>

<ul>
<li>OfflineApp.encodeAppXml</li>
<li>OfflineApp.decodeAppXml</li>
<li>OfflineApp.encodeAppBinary</li>
<li>OfflineApp.decodeAppBinary</li>
</ul>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='logging.html'>Prev</a>
 | <a href='security.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







