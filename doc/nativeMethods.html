<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    29 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Native Methods</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='memory.html'>Prev</a>
 | <a href='logging.html'>Next</a>
</div>
<h1 class='title'>Native Methods</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!-- /////////////////////////////////////////////////////// -->
<h1 id="overview">Overview</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Native methods are used to create Sedona APIs that bind to native
code written in the C programming language.  The following steps
are used to create a native method:
</p>

<ol>

<li><b>Native Id</b>: every native method is assigned a unique two
  byte identifier in <code>kit.xml</code></li>

<li><b>Sedona Stub</b>: every native method is declared as a normal
  method in Sedona using the <code>native</code> modifier</li>

<li><b>Native Implementation</b>: native methods are implemented as
  functions in the C programming language</li>

<li><b>Native Tables</b>: function pointers to all native implementations
   are mapped into tables for dispatch by the Sedona VM</li>

</ol>       

<p>
When running on the Java VM, native methods are implemented in the
Java language - see the <a href='jvm.html#nativeMethods'>Java VM</a>
chapter.            
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="id">Native Id</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Every native method is assigned a two byte identifier used to dispatch a
Sedona call to the proper C function.  The top byte is the <i>kitId</i>
and the bottom byte is the <i>methodId</i>.  Native ids are formatted as
"kitId::methodId".
</p>

<p>
Each kit that contains native methods should be assigned a unique kitId.
Technically kitIds don't need to be globally unique, but should be unique
across all the kits that might be used together for a given platform.  The
range of kitIds from 0 to 99 is reserved for core Sedona kits.  Third
parties should use kitIds from 100 to 255, or coordinate with the core Sedona
development team.  The <code>sys</code> kit itself is assigned the kitId of zero.
</p>

<p>
Within a kit, every native method is assigned a unique methodId.  Because
the methodId is only a byte, there can be at most 255 native methods in
a single kit.  Although if necessary a given kit could consume multiple
kitIds (this is not currently supported by the sedonac stub tool).
</p>

<p>
The list of native ids for a kit is defined in the <code>kit.xml</code>
file using the following XML format:
</p>

<pre>
&lt;natives>
  &lt;native qname="foo::Type1.method1" id="6::0" />
  &lt;native qname="foo::Type1.method2" id="6::1" />
  &lt;native qname="foo::Type2.method1" id="6::2" />
&lt;/natives>
</pre>

<p>
The <code>natives</code> element contains one or more <code>native</code>
elements for each native method in the kit.  The <code>native</code> element
contains two required attributes: <code>qname</code> specifies the qualified
name of the native method and <code>id</code> specifies the native id formatted
as "kitId::methodId".
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="stubs">Sedona Stubs</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Native methods are declared as normal Sedona methods but without a
method body (just like abstract methods).  Native methods must be flagged
with the <code>native</code> keyword.  Native methods cannot be
<code>abstract</code> or <code>virtual</code>.  For example:
</p>

<pre>
class Type2
{
  static native int add(int a, int b)
  static native void test(bool z, int i, float f)
}
</pre>

<p>
The Sedona compiler will perform a series of checks upon the native ids
and native stubs when compiling source code into a kit file (in the
<code>ResolveNatives</code> step).  Unless errors are detected, the native
ids are written into the appropriate IR files of the kit.  If any native
ids are modified, you must recompile from source.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="impl">Native Implementation</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The Sedona VM is stack based.  Each item on the stack is called a <i>Cell</i>,
which is a union of <code>int32_t</code>, <code>float</code>, and
<code>void*</code>.  Unless you are running on a 64-bit processor, a
Cell is 32-bits wide.  The definition of Cell in <code>sedona.h</code> is:
</p>

<pre>
typedef union
{
  int32_t ival;    // 32-bit signed int
  float   fval;    // 32-bit float
  void*   aval;    // address pointer
}
Cell;
</pre>

<p>
Every native method must be implemented in C as a function that takes
a Cell pointer into the stack and returns a Cell.  The typedef for a
native method pointer in <code>sedona.h</code> is:
</p>

<pre>
typedef Cell (*NativeMethod)(Cell* params);
</pre>

<p>
The parameters are passed as a Cell pointer to the first parameter.  You
can manually extract the individual parameters using array indexing.  If
the native method is not static, then the implicit <code>this</code> pointer
is always parameter 0.  
</p>
<p>
It is important to note that all native methods return a Cell value
even when the Sedona signature has a <code>void</code> return.  You can use
the constant <code>nullCell</code> 
to return from a Sedona method that returns <code>void</code>.  
Constants <code>trueCell</code> and <code>falseCell</code> can similarly be used for
<code>bool</code> returns.
</p>

<p>
An example implementation of the <code>foo::Type2.add</code> method:
</p>

<pre>
Cell foo_Type2_add(Cell* params)
{
  int32_t a = params[0].ival;
  int32_t b = params[1].ival;
  Cell result;
  
  result.ival = a+b;
  
  return result
}
</pre>
<p>
An example implementation of the <code>foo::Type2.test</code> method:
</p>

<pre>
Cell foo_Type2_test(Cell* params)
{
  int32_t z = params[0].ival;
  int32_t b = params[1].ival;
  float   f = params[2].fval;
  
  printf("test %d %d %f\n", z, b, f);

  return nullCell;
}
</pre>



<p>
Note in the examples above how each parameter is extracted using array indexing
and the union member name.  Pointers (including strings) should use the <code>aval</code> member,
<code>floats</code> the <code>fval</code> member, and all other primitives are
accessed using the <code>ival</code> member.  Note that a Sedona <code>bool</code>
maps into zero and non-zero for <code>false</code> and <code>true</code>
respectively.  Arrays of primitives are accessed like their C counterparts.
</p>

<p>
Native methods that pass or return <code>long</code> or <code>double</code> are a bit
trickier.  A single <code>long</code> or <code>double</code> value requires
two Cells to store the full 64-bits.  
To access a <code>long</code> or 
<code>double</code> function argument requires the use of pointer casting to access 
two consecutive elements of the parameter array.  
A native method that returns a <code>long</code>
or <code>double</code> should declare the return type to be <code>int64_t</code>
instead of <code>Cell</code>. The following is an example - note how each
<code>long</code> parameter actually consumes two cells of the parameter list:
</p>

<pre> 
native static long addTwoLongs(long a, long b)

int64_t foo_Type3_addTwoLongs(Cell* params)
{
  int64_t a = *(int64_t*)(params+0); // param 0+1
  int64_t b = *(int64_t*)(params+2); // param 2+3
  return a+b;
}
</pre>  

<p>
A summary of common mappings from Sedona to their C equivalents:
</p>

<table>
<tr>
  <th>Sedona</th> <th>C</th>
  <th></th>
  <th>Sedona</th> <th>C</th>
</tr>
<tr>
  <td>bool</td>   <td>int32_t</td>
  <td></td>
  <td>bool[]</td> <td>uint8_t*</td>
</tr>
<tr>
  <td>byte</td>   <td>int32_t</td>
  <td></td>
  <td>byte[]</td> <td>uint8_t*</td>
</tr>
<tr>
  <td>short</td>   <td>int32_t</td>
  <td></td>
  <td>short[]</td> <td>uint16_t*</td>
</tr>
<tr>
  <td>int</td>   <td>int32_t</td>
  <td></td>
  <td>int[]</td> <td>int32_t*</td>
</tr>
<tr>
  <td>long</td>   <td>int64_t</td>
  <td></td>
  <td>long[]</td> <td>int64_t*</td>
</tr>
<tr>
  <td>float</td>   <td>float</td>
  <td></td>
  <td>float[]</td> <td>float*</td>
</tr>
<tr>
  <td>double</td>   <td>double</td>
  <td></td>
  <td>double[]</td> <td>double*</td>
</tr>
<tr>
  <td>Obj</td>   <td>void*</td>
  <td></td>
  <td>Obj[]</td> <td>void**</td>
</tr>
<tr>
  <td>Str</td>   <td>uint8_t*</td>
  <td></td>
  <td>Str[]</td> <td>uint8_t**</td>
</tr>
</table>

<p>
Note that Sedona strings can be used as a normal null terminated C string.
</p>

<p>
Refer to the <a href='porting.html#natives'>Porting</a> chapter for how
to structure your native C code.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="tables">Native Tables</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
When the Sedona VM is compiled, the VM is bound to a lookup table
for all the native methods available.  This lookup table is a two
level array of function pointers.  The first level of the array
maps to the kitIds and the second level maps to the methodIds.  For
example to lookup the function pointer for the native id of
"2::7" would be <code>nativeTable[2][7]</code>.
</p>

<p>
The native lookup table is automatically generated as "nativetable.c"
when <code>sedonac</code> is used to <a href="porting.html#staging">stage a VM</a>.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="issues">Additional Issues</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The existing native method facility provides low level hooks to bind
Sedona APIs into the native platform.  However due to its low level nature
it maps fairly closely to the stack architecture of the VM.  This design
has the major limitation that it only works well when accessing primitives
off the stack.  There is currently no safe mechanism to access individual 
fields of a Sedona object within a native method, as you would need to 
know exactly how the compiler will layout the memory (even then it would 
be quite brittle).  In the meantime the best
practice is to pass only primitives (or arrays of primitives) as parameters.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="predefined">Predefined Kit Ids</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The following are the predefined native kit ids:
</p>

<table>
  <tr> <td>sys</td>               <td>0</td></tr>
  <tr> <td>mac154</td>            <td>2</td></tr>        
  <tr> <td>inet</td>              <td>3</td></tr>
  <tr> <td>serial</td>            <td>4</td></tr>
  <tr> <td>smbus</td>             <td>5</td></tr>
  <tr> <td>jace</td>              <td>6</td></tr>      
  <tr> <td>jennic</td>            <td>7</td></tr>        
  <tr> <td>jenNet</td>            <td>8</td></tr>        
  <tr> <td>basicio</td>           <td>9</td></tr>        
  <tr> <td>datetimeOS</td>        <td>10</td></tr>        
  <tr> <td>bacnet</td>            <td>11</td></tr>        
  <tr> <td>spibus</td>            <td>12</td></tr>        
  <tr> <td>memtool</td>           <td>13</td></tr>        
  <tr> <td>nrio</td>              <td>20</td></tr>         
</table>

<br/>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='memory.html'>Prev</a>
 | <a href='logging.html'>Next</a>
</div>
<div class='copyright'>Copyright &#169; 2007-2009 Tridium, Inc.</div>
</body>
<!-- TOC-FOOTER-END -->

</html>







