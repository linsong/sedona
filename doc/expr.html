<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    12 Sep 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Expressions</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='style.css'/>
</head>
<body>
<p>
  <a href='index.html'>
    <img src='logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='primitives.html'>Prev</a>
 | <a href='stmt.html'>Next</a>
</div>
<h1 class='title'>Expressions</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!--/////////////////////////////////////////////////////////-->
<h1 id="overview">Overview</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Expressions are almost identical to those found in C or Java.
The same operator precedence rules apply:
</p>

<table>
<tr> <td>Accessors</td>      <td><code>. ?. () []</code></td> </tr>
<tr> <td>Unary</td>          <td><code>- ! ~ ++ -- (cast)</code></td> </tr>
<tr> <td>Multiplicative</td> <td><code>* / %</code></td> </tr>
<tr> <td>Additive</td>       <td><code>+ -</code></td> </tr>
<tr> <td>Bitwise Shift</td>  <td><code>&gt;&gt; &lt;&lt;</code></td> </tr>
<tr> <td>Elvis</td>          <td><code>?:</code></td> </tr>
<tr> <td>Relational</td>     <td><code>&lt; &lt;= &gt; &gt;=</code></td> </tr>
<tr> <td>Equality</td>       <td><code>== !=</code></td> </tr>
<tr> <td>Bitwise AND</td>    <td><code>&amp;</code></td> </tr>
<tr> <td>Bitwise XOR</td>    <td><code>^</code></td> </tr>
<tr> <td>Bitwise OR</td>     <td><code>|</code></td> </tr>
<tr> <td>Logical AND</td>    <td><code>&amp;&amp;</code></td> </tr>
<tr> <td>Logical OR</td>     <td><code>||</code></td> </tr>
<tr> <td>Ternary</td>        <td><code>? :</code></td> </tr>
<tr> <td>Assignment</td>     <td><code>= += -= *= /= |= ^= &amp;= &gt;&gt;= &lt;&lt;=</code></td> </tr>
</table>

<!--/////////////////////////////////////////////////////////-->
<h1 id="arithmetic">Arithmetic Operators</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The following arithmetic operators may be used with numeric primitives:
</p>

<table>
  <tr> <th>Name</th>                <th>Operator</th> </tr>
  <tr> <td>Multiplication</td>      <td><code>x * y</code></td> </tr>
  <tr> <td>Division</td>            <td><code>x / y</code></td> </tr>
  <tr> <td>Modulus (remainder)</td> <td><code>x % y</code></td> </tr>
  <tr> <td>Addition</td>            <td><code>x + y</code></td> </tr>
  <tr> <td>Subtraction</td>         <td><code>x - y</code></td> </tr>
  <tr> <td>Negation</td>            <td><code>-x</code></td> </tr>
  <tr> <td>Prefix Increment</td>    <td><code>++x</code></td> </tr>
  <tr> <td>Prefix Decrement</td>    <td><code>--x</code></td> </tr>
  <tr> <td>Postfix Increment</td>   <td><code>x++</code></td> </tr>
  <tr> <td>Postfix Decrement</td>   <td><code>x--</code></td> </tr>
</table>

<p>The Modulus operator is only available for integer types,
it may not be used with floats or doubles.</p>

<p>The prefix/postfix operators work just like C and Java.  If
using the prefix operator the result of the expression is the
new value.  If using the postfix operator the result is the
old value:</p>

<pre>
  int x = 4    // x == 4
  int y = ++x  // x == 5, y == 5
  int z = x++  // x == 6, z == 5
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="bitwise">Bitwise Operators</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The following bitwise operators may be used with integer primitives (byte,
short, int, long):
</p>

<table>
  <tr> <th>Name</th>        <th>Operator</th> </tr>
  <tr> <td>Or</td>          <td><code>x | y</code></td> </tr>
  <tr> <td>Xor</td>         <td><code>x ^ y</code></td> </tr>
  <tr> <td>And</td>         <td><code>x &amp; y</code></td> </tr>
  <tr> <td>Left Shift</td>  <td><code>x &lt;&lt; y</code></td> </tr>
  <tr> <td>Right Shift</td> <td><code>x &gt;&gt; y</code></td> </tr>
  <tr> <td>Not</td>         <td><code>~x</code></td> </tr>
</table>

<!--/////////////////////////////////////////////////////////-->
<h1 id="logical">Logical Operators</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The following logical operators may be used with booleans:
</p>

<table>
  <tr> <th>Name</th>   <th>Operator</th> </tr>
  <tr> <td>Or</td>     <td><code>x || y</code></td> </tr>
  <tr> <td>And</td>    <td><code>x &amp;&amp; y</code></td> </tr>
  <tr> <td>Not</td>    <td><code>!x</code></td> </tr>
</table>

<p>
Both the Or and And operators are short circuiting.  If
the first term of Or evaluates to true, then the second
term is not evaluated.  If the first term of And
evaluates to false, then the second term is not evaluated.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="comparison">Comparison</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The following operators are used for comparison:
</p>

<table>
  <tr> <th>Name</th>                  <th>Operator</th> </tr>
  <tr> <td>Equal</td>                 <td><code>x == y</code></td> </tr>
  <tr> <td>Not Equal</td>             <td><code>x != y</code></td> </tr>
  <tr> <td>Greater Than</td>          <td><code>x &gt; y</code></td> </tr>
  <tr> <td>Greater Than or Equal</td> <td><code>x &gt;= y</code></td> </tr>
  <tr> <td>Less Than</td>             <td><code>x &lt; y</code></td> </tr>
  <tr> <td>Less Than or Equal</td>    <td><code>x &lt;= y</code></td> </tr>
</table>

<p>
Non-numeric types may only use the equality (<code>==</code> and
<code>!=</code>) operators.  Reference types compare identity (pointer
address).
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="assignment">Assignment</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The <code>=</code> operator is used to assign the right hand side
expression to the left hand side.  The left hand side must be
<i>assignable</i>.  Assignable expressions are local variables,
fields, and array indices.
</p>

<p>
The compound assignment operators <code>+= -= *= /= |= ^= &amp;= &gt;&gt;= &lt;&lt;=</code>
can be used to combine an arithmetic or bitwise operator with
assignment:
</p>

<pre>
  int x = 5   // x == 5
  x += 3      // x == 8
</pre>

<!--/////////////////////////////////////////////////////////-->
<h2 id="propassign">Assigning to Properties</h2>
<!--/////////////////////////////////////////////////////////-->

<p>
If the left hand side of an assignment expression is a 
<a href='components.html#properties'>component property</a>
then you must use the <b>:=</b> assignment operator instead of
<b>=</b>.  This highlights the fact that assigning a new value
to a property results in more than just the storage of the new
value; it also has potential side effects that may not always be
visible to the user.
</p>
<p>
Note that there are no compound property assignment operators;
increment, decrement, etc must be spelled out explicitly in the
expression.</p>

<pre>
// Property px
property int px

// Non-property field ix
int ix

void myfunc()
{
  // Use := when lhs is a property
  px := 3

  // Use = when lhs is a non-property
  ix = px

  // No compound assignment operators
  px := px + 1
}
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="casting">Casting</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona uses a syntax just like C or Java to perform a cast.  Casts
are required when the compiler cannot perform a static type check.
For example, if you need to assign an Obj to a Component, then you
must use a cast: <code>c = (Component)obj</code>.  This type of cast is for
compile time checking only, at runtime it is basically a no-op like C.
</p>

<p>
Casts are also used with numeric types to perform a type conversion.
For example to convert an int into a float: <code>f = (float)i</code>.
Note that unlike C and Java, upcasts such as from an int to a long are
not implicit - you must be explicitly use a cast.
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="safeNav">Safe Navigation</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona supports Groovy's <i>safe navigation</i> operator: <code>x?.slot</code>.
You can use the safe nav operator to access fields or call methods.
If the target expression of a slot access is null, then the whole expression
short circuits to evaluate to null.  If the field or method returns a
primitive then it short circuits to false/zero. Using the safe nav
operator is a convenient and more efficient way than manually checking
for null:
</p>

<pre>
  // hard way
  DeviceNetwork net = null
  if (point != null)
  {
    Device dev = point.getDevice()
    if (dev != null) net = dev.getNetwork()
  }

  // easy way
  DeviceNetwork net = point?.getDevice()?.getNetwork()
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="elvis">Elvis</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona supports Groovy's <i>elvis</i> operator: <code>lhs ?: rhs</code>.
If lhs evaluates to null, then the whole expression evaluates to
rhs.  If lhs is non-null, then the rhs is short circuited and the
whole expression evaluates to lhs.  The elvis operator is a convenient
and more efficient way to write code where you might use the
ternary operator:
</p>

<pre>
  // hard way
  name != null ? name : "unknown"

  // easy way
  name ?: "unknown"
</pre>

<!--/////////////////////////////////////////////////////////-->
<h1 id="ternary">Ternary</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona supports the C/Java ternary operator: <code>c ? t : f</code>.
The boolean expression <code>c</code> is evaluated.  If true
then the ternary expression evaluates to <code>t</code>, otherwise
it evaluates to <code>f</code>:
</p>

<pre>
  bool x = true
  Str msg = x ? "On" : "Off"   // msg == "On"
  x = false
  msg = x ? "On" : "Off"       // msg == "Off"
</pre>


<!--/////////////////////////////////////////////////////////-->
<h1 id="interpolation">Str Interpolation</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
Sedona supports string interpolation, which allows for concise
string formatting.  String interpolation can be used with any method
that has one <code>Str</code> parameter and returns an <code>OutStream</code>.
You may use the <code>"+"</code> operator to concatenate multiple
expressions to a string literal:
</p>

<pre>
  // using the + operator
  int x = 77
  Sys.out.print("x=" + x)

  // is equivalent to this statement
  Sys.out.print("x=").printInt(x)
</pre>

<p>
The example above illustrates why interpolation is only used
with methods that take a <code>Str</code> and return an
<code>OutStream</code>.  The compiler doesn't actually create
a new string, rather it chains multiple print calls.
</p>

<p>
Use of the "+" operator is allowed, but the preferred mechanism
for string formatting is to embed the expressions directly into
the string literal itself using the <code>'$'</code> character.  You
can embed any arbitrary expression into a string literal using
the syntax <code>"${expr}"</code>.  If the expression is a simple
variable name or a variable name followed by a dot field access,
then you can omit the curly braces.  Use the <code>'\$'</code>
escape sequence to print the dollar sign itself.  Some examples:
</p>

<pre>
  // example from above
  Sys.out.print("x=${x}")

  // same but omitting the braces
  Sys.out.print("x=$x")

  // embedded expressions
  Sys.out.print("x=0x${Sys.hexStr(x)}")
</pre>

<p>
The following types are supported with string interpolation:
</p>

<table border='1'>
<tr><th>Type</th><th>Print Method</th></tr>
<tr><td><code>Str</code></td>    <td><code>OutStream.print</code></td></tr>
<tr><td><code>bool</code></td>   <td><code>OutStream.printBool</code></td></tr>
<tr><td><code>int</code></td>    <td><code>OutStream.printInt</code></td></tr>
<tr><td><code>long</code></td>   <td><code>OutStream.printLong</code></td></tr>
<tr><td><code>float</code></td>  <td><code>OutStream.printFloat</code></td></tr>
<tr><td><code>double</code></td> <td><code>OutStream.printDouble</code></td></tr>
</table>

<p></p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='index.html'>Index</a>
 | <a href='primitives.html'>Prev</a>
 | <a href='stmt.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







