<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2009 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    07 Jan 2010 - Matthew Giannini creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Platform Tutorial</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='../style.css'/>
</head>
<body>
<p>
  <a href='../index.html'>
    <img src='../logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='../index.html'>Index</a>
 | <a href='par.html'>Prev</a>
 | <a href='deviceSim.html'>Next</a>
</div>
<h1 class='title'>Platform Tutorial</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<p>A Sedona Framework platform is simply any device running an SVM. The platform is
uniquely identified by the <b><i>platformId</i></b> property of the platform
service running in the app on that device.</p>

<p>This section presents a high-level, step-by-step guide to creating a Sedona Framework platform
for your own device. We will use the Win32 platform provided in the open source
distribution as a case study in creating a new Sedona Framework platform.</p>

<ol>
  <li><a href="#step1">Step 1:</a> Create a kit for your platform service</li>
  <li><a href="#step2">Step 2:</a> Implement PlatformService native methods</li>
  <li><a href="#step3">Step 3:</a> Create a platform definition file</li>
  <li><a href="#step4">Step 4:</a> Port the SVM</li>
  <li><a href="#step5">Step 5:</a> Build the SVM</li>
  <li><a href="#step6">Step 6:</a> Create a PAR file</li>
  <li><a href="#step7">Step 7:</a> SAX and Scode setup for your platform</li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step1">Step 1: Create a kit for your platform service</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Every app must have a <code>sys::PlatformService</code> component
running in it. A platform service encapsulates the behavior of that 
specific OS/Hardware platform.  The <code>sys::PlatformService</code>
class itself is generic, so some key methods do nothing.
To implement a real Sedona platform, it must be subclassed so that 
platform-specific behavior can be implemented.
</p>

<p>
The first step in porting Sedona to a new platform is the creation of
a PlatformService subclass for the platform.
As an example, the win32 platform service is defined in a kit called "platWin32" and
the kit definition file is in 
<code><i>sedona_home</i>/platforms/src/generic/win32/kit.xml</code>
</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step2">Step 2: Implement PlatformService native methods</h1>
<!--/////////////////////////////////////////////////////////-->

<p>
The base class <code>sys::PlatformService</code> defines three native methods 
that must be implemented for every platform.  
They are called by <code>PlatformService</code> as needed to populate
the corresponding properties.
</p>

<ul>
<li><code>doPlatformId()</code>: returns platform ID string</li>
<li><code>getPlatVersion()</code>: returns platform version string</li>
<li><code>getNativeMemAvailable()</code>: returns number of bytes of physical memory available</li>
</ul>

<p>
The open source includes win32 natives as an example, see
<code><i>sedona_home</i>/src/sys/native/win32</code>.
</p>

<p id="doPlatformId">
One of the most important properties on the platform
service is the <code>platformId</code> property. This property uniquely
identifies your platform, and maps to a platform manifest stored in the
platform database.  The native method <code>doPlatformId()</code> provides
a means for Sedona to access this native property.
</p>
<p>
The native implementation of <code>doPlatformId()</code> for the win32 platform is
</p>

<pre>
#include "sedona.h"
#include "sedonaPlatform.h"
#include &lt;windows.h>

// Str PlatformService.doPlatformId()
Cell sys_PlatformService_doPlatformId(SedonaVM* vm, Cell* params)
{
  Cell result;
  result.aval = PLATFORM_ID;
  return result;
}
</pre>

<p>
The value of <code>PLATFORM_ID</code> is defined in the header file <code>sedonaPlatform.h</code>,
which is generated automatically from the platform definition XML file. 
So the next step is to create one.
</p>

<br/>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step3">Step 3: Create a platform definition XML file</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Please refer to the section on <a href="platDef.html">platform definition</a>
for an in depth discussion of this file and all its sections and attributes.</p>

<p> The platform definition for the win32 platform is located in
<code><i>sedona_home</i>/platforms/src/generic/win32/generic-win32.xml</code>.
(This file can be located anywhere, but the convention is to put it under
<code><i>sedona_home</i>/platforms/src/</code>.)
</p>

<pre>
&lt;sedonaPlatform vendor="Tridium" id="tridium-generic-win32-${sedona.env.version}" >

  &lt;compile endian="little" blockSize="4" refSize="4" debug="true" test="true">

    &lt;!-- Native Kits -->
    &lt;nativeKit depend="sys 1.0" />
    &lt;nativeKit depend="inet 1.0" />
    &lt;nativeKit depend="datetimeStd 1.0" />
    &lt;nativeKit depend="platWin32 1.0" />

    &lt;!-- Native Sources -->
    &lt;nativeSource path="/src/vm" />
    &lt;nativeSource path="/src/sys/native" />
    &lt;nativeSource path="/src/sys/native/std" />
    &lt;nativeSource path="/src/sys/native/win32" />
    &lt;nativeSource path="/src/inet/native" />
    &lt;nativeSource path="/src/inet/native/std" />
    &lt;nativeSource path="/src/inet/native/sha1" />
    &lt;nativeSource path="/src/datetimeStd/native/std" />
    &lt;nativeSource path="/platforms/src/generic/win32/native" />
  &lt;/compile>

&lt;/sedonaPlatform>
</pre>

<p>There are a few things to note about this platform definition.</p>

<ol>
  <li>It specifies the <code>id</code> attribute for the platform. Later, when we
  run <code>sedonac</code> on this file to stage the source, it will generate the header file 
  <code>sedonaPlatform.h</code> based on this file. 
  That header file will contain the <code>PLATFORM_ID</code> definition
  required by the <a href="#doPlatformId">doPlatformId()</a> native code.
  </li>
  <li>The SVM created from this platform definition will only support 
  the native methods from the sys, inet, datetimeStd, and platWin32 kits because 
  those are the only kits included in <code>&lt;nativeKit></code> declarations.
  In order to support other kits with native methods, they will have to be added
  to the platform definition.
  </li>
</ol>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step4">Step 4: Port the SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>This process is already described in detail in the <a href="porting.html">porting</a>
section. We specified in the platform definition file where all the native source
code is located.  If the native source file locations change at
any time during the platform development process, the platform definition will 
need to be updated accordingly.
</p>

<p>Refer to the win32 platform definition to see where all the
native code for the win32 SVM resides.</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step5">Step 5: Build the SVM</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Once the native source code is written and the platform definition file is
correct, we are ready to build the SVM. 
As described in the <a href="porting.html#staging">staging</a>
section, we use <code>sedonac</code> to stage all native source files in one
directory. Then we use the appropriate native tool-chain to
actually build the SVM.</p>

<p>The open source distribution includes a <code>makewinvm.py</code> script
that will build the win32 platform SVM. It runs <code>sedonac</code> on the
generic-win32.xml platform definition file to stage all the source code for the
SVM, and then it compiles the source code into a binary. This is the same <code>svm.exe</code>
that appears in the <code>bin/</code> directory of the open source distribution. To run
<code>makewinvm.py</code> you must first have <a href="setup.html">set up</a> 
your environment for Windows 32-bit development.</p>

<p>You must provide your own native tool-chain to accomplish the same tasks
for a different platform.</p>

<!--/////////////////////////////////////////////////////////-->
<h1 id="step6">Step 6: Create a PAR file for your platform</h1>
<!--/////////////////////////////////////////////////////////-->

<p>Refer to the section on <a href="par.html">PAR files</a> for a more in-depth
discussion on PAR files.</p>

<p>When we staged the native source by running <code>sedonac</code> on the
platform definition file, it also created a <code>.par/</code> directory 
containing a valid platformManifest.xml file for the platform.
Therefore, all we need to do is zip up the contents
of that directory and use the platformdb.py script to install it in our platform database.</p>

<p>The <code>makewinvm.py</code> script does the database installation step automatically 
for the open source win32 platform. 
If you issue the <code>platformdb.py --list</code> command you should see output similar
to the following</p>

<pre>
sedona&gt; platformdb.py --list
 tridium-generic-win32-1.0.46
</pre>

<p>This output indicates that the we have successfully installed the win32 platform
into the platform database.  The toolchain steps you perform for another platform 
will need to do the same thing for that platform.
You can use the <code>platformdb -i &lt;par file&gt;</code> command to install a PAR file
into the platform database.</p>

<p>Note that the path within the platform database where the .par folder will be located
<b>must</b> match the platform ID exactly.  For example, note that the win32 platform definition
file defines the platform ID as <code>tridium-generic-win32-${sedona.env.version}</code>.
When we ran <code>sedonac</code> on the platform definition file it substituted an actual
version number, so the resulting platform manifest file contains a specific definition, for
example <code>tridium-generic-win32-1.2.29</code>.
Sedona would then expect to find the manifest file for this platform in the platform
database under 
<code><i>sedona_home</i>/platforms/db/tridium/generic/win32/1.2.29/.par/</code>.

</p>


<!--/////////////////////////////////////////////////////////-->
<h1 id="step7">Step 7: SAX and Scode setup for your platform</h1>
<!--/////////////////////////////////////////////////////////-->

<p>To use your new platform service, you will need to create an application
(SAX) that uses your platform service. There is an example SAX file that uses
the Win32PlatformService at <code><i>sedona_home</i>/apps/platWin32.sax</code>.
You can use this file as a template and make the following modifications to use it
for your platform:</p>
<ol>
<li>In the <code>&lt;schema></code> section, remove the platWin32 kit and add the kit
for your platform service.</li>
<li>In the <code>&lt;app></code> section there is a component called "plat".
Change the type of that component from "platWin32::Win32PlatformService" to the
type of your platform service.</li>
</ol>

<p>After you have made these changes you can run <code>sedonac</code> on your new SAX file
to create an binary application (SAB) that your SVM can run.</p>

<p>
Finally, you will need to create a scode image corresponding to the kits in your
SAX.  There is an example scode configuration file in 
<code><i>sedona_home</i>/scode/platWin32.xml</code>.
You can use this file as a template and make the following modifications for your
platform:</p>

<ol>
<li>Modify the <code>&lt;sedonaCode&gt;</code> elements to match the settings
for your device. For example, make sure the blockSize, refSize, endian, etc.
are correct.</li>
<li>Remove the dependency on "platWin32 1.0" and add a dependency for the
kit containing your platform service.</li>
</ol>

<p>After you have made these changes you an run <code>sedonac</code> on your new scode XML
file to produce an scode image that your SVM can run.</p>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='../index.html'>Index</a>
 | <a href='par.html'>Prev</a>
 | <a href='deviceSim.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







