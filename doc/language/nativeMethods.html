<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<!--

  Copyright (c) 2007 Tridium, Inc
  Licensed under the Academic Free License version 3.0

  History:
    29 Mar 07  Brian Frank  Creation

-->

<!-- TOC-HEADER-START -->
<!-- Auto-generated by sedonac -->
<head>
  <title>Native Methods</title>
  <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
  <link rel='stylesheet' type='text/css' href='../style.css'/>
</head>
<body>
<p>
  <a href='../index.html'>
    <img src='../logo.png' alt='Sedona'/>
  </a>
</p>
<div class='nav'>
  <a href='../index.html'>Index</a>
 | <a href='memory.html'>Prev</a>
 | <a href='logging.html'>Next</a>
</div>
<h1 class='title'>Native Methods</h1>
<div class='content'>
<!-- TOC-HEADER-END -->

<!-- /////////////////////////////////////////////////////// -->
<h1 id="overview">Overview</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Native methods are used to create Sedona APIs that bind to native
code written in the C programming language.  The following steps
are used to create a native method:
</p>

<ol>

<li><b>Native Id</b>: Every native method is assigned a unique two
  byte identifier in the kit's <code>kit.xml</code> file</li>

<li><b>Stub</b>: Every native method is declared in the Sedona code 
  using the <code>native</code> modifier</li>

<li><b>Native Implementation</b>: Native methods are implemented as
  functions in the C programming language</li>

  <li><b>Native Tables</b>: At staging, function pointers to the native 
  implementations are mapped into tables for dispatch by the SVM at runtime</li>

</ol>


<!-- /////////////////////////////////////////////////////// -->
<h1 id="id">Native Id</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Every native method is assigned a two byte identifier used to dispatch a
call to the proper C function.  The first byte is the <i>kitId</i>
and the second byte is the <i>methodId</i>.  Native ids are expressed as
"kitId::methodId".
</p>

<p>
Each kit that contains native methods should be assigned a unique kitId.
Technically kitIds don't need to be globally unique, but they must be unique
across all the kits that might be used together for a given platform.  The
range of kitIds from 0 to 99 is reserved for core Sedona Framework kits.  Third
parties should use kitIds from 100 to 255 (or contact the Sedona Framework
development team).  The <code>sys</code> kit itself is assigned the kitId of zero.
Any <a href='platTutorial.html'>platform service</a> kit 
(i.e. a platform-specific kit containing a PlatformService
subclass) can be given a kitId of 1, since there will never be more than one such
kit loaded on a Sedona device at any given time.
</p>

<p>
Within a kit, every native method is assigned a unique methodId.  Because
the methodId is only a byte, there can be at most 255 native methods in
a single kit.  
</p>

<p>
The list of native ids for a kit is defined in the <code>kit.xml</code>
file using the following XML format:
</p>

<pre>
&lt;natives>
  &lt;native qname="foo::Type1.method1" id="6::0" />
  &lt;native qname="foo::Type1.method2" id="6::1" />
  &lt;native qname="foo::Type2.method1" id="6::2" />
&lt;/natives>
</pre>

<p>
The <code>natives</code> element contains one or more <code>native</code>
elements for each native method in the kit.  The <code>native</code> element
contains two required attributes: <code>qname</code> specifies the qualified
name of the native method and <code>id</code> specifies the native id formatted
as "kitId::methodId".  In this example, the kitId for kit <code>foo</code> is 6,
and the native method methodIds are 0, 1, and 2.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="stubs">Stubs</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
Native methods are declared like normal methods but without a
method body (just like abstract methods).  Native methods must be flagged
with the <code>native</code> keyword.  Native methods cannot be
<code>abstract</code> or <code>virtual</code>.  For example:
</p>

<pre>
class Type2
{
  static native int add(int a, int b)
  static native void test(bool z, int i, float f)
  native float  testf(int i, float f)
}
</pre>

<p>
The compiler will perform a series of checks upon the native ids
and native stubs when compiling source code into a kit file (in the
<code>ResolveNatives</code> step).  Unless errors are detected, the native
ids are written into the appropriate IR files of the kit.  If any native
ids are modified, you must recompile from source.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="impl">Native Implementation</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The SVM is stack based.  Each item on the stack is called a <i>Cell</i>,
which is a union of <code>int32_t</code>, <code>float</code>, and
<code>void*</code>.  Unless you are running on a 64-bit processor, a
Cell is 32-bits wide.  The definition of Cell in <code>sedona.h</code> is:
</p>

<pre>
typedef union
{
  int32_t ival;    // 32-bit signed int
  float   fval;    // 32-bit float
  void*   aval;    // address pointer
}
Cell;
</pre>

<p>
Every native method must be implemented in C as a function that takes two arguments:
a <code>SedonaVM_s</code> pointer and a <code>Cell</code> pointer into the stack, 
and returns a <code>Cell</code>. 
(Native methods that return a <code>long</code> or a <code>double</code> require 
special handling, described in more detail below). The definition for SedonaVM_s is
in <code>sedona.h</code>.  The typedef for a native method pointer is:
</p>

<pre>
typedef Cell (*NativeMethod)(struct SedonaVM_s* vm, Cell* params);
</pre>

<p>
The method parameters are accessed from the stack via the Cell pointer <code>params</code>.  
You can manually extract the individual parameters using array indexing.  
If the native method is not static, then parameter 0 is always the implicit 
<code>this</code> pointer.
</p>

<p>
It is important to note that all native method implementations return a Cell value even
when the Sedona signature for the method returns <code>void</code>. You can use the
constant <code>nullCell</code> to return from a method that returns <code>void</code>.
Other predefined Cell constants are <code>trueCell</code>, <code>falseCell</code>,
<code>zeroCell</code>, <code>oneCell</code>, and <code>negOneCell</code>.
</p>

<p>
An example implementation of the <code>foo::Type2.add</code> method:
</p>

<pre>
Cell foo_Type2_add(SedonaVM* vm, Cell* params)
{
  int32_t a = params[0].ival;
  int32_t b = params[1].ival;
  Cell result;

  result.ival = a+b;

  return result
}
</pre>
<p>
An example implementation of the <code>foo::Type2.test</code> method:
</p>

<pre>
Cell foo_Type2_test(SedonaVM* vm, Cell* params)
{
  int32_t z = params[0].ival;
  int32_t b = params[1].ival;
  float   f = params[2].fval;

  printf("test %d %d %f\n", z, b, f);

  return nullCell;
}
</pre>



<p>
An example implementation of the (non-static) <code>foo::Type2.testf</code> method:
</p>

<pre>
Cell foo_Type2_testf(SedonaVM* vm, Cell* params)
{
  void* this = params[0].aval;   /* 'this' pointer is implicit first element of params[] */
  int32_t b  = params[1].ival;
  float   f  = params[2].fval;
  Cell result;

  result.fval = b*f;

  printf("test %d*%f=%f\n", b, f, result.fval);

  return result;
}
</pre>



<p>
Note in the examples above how each parameter is extracted using array indexing
and the union member name.  Pointers (including strings) should use the <code>aval</code> member,
<code>floats</code> the <code>fval</code> member, and all other primitives are
accessed using the <code>ival</code> member.  Note that a Sedona <code>bool</code>
maps into zero and non-zero for <code>false</code> and <code>true</code>
respectively.  Arrays of primitives are accessed like their C counterparts.
</p>

<p>
Native methods that pass or return <code>long</code> or <code>double</code>
are a bit trickier. A single <code>long</code> or <code>double</code> value
requires two Cells to store the full 64-bits. To access a <code>long</code> or <code>double</code>
function argument requires the use of pointer casting to access two consecutive
elements of the parameter array. A native method that returns a <code>long</code>
or <code>double</code> should declare the return type to be <code>int64_t</code>
instead of <code>Cell</code>. The following is an example - note how each <code>long</code>
parameter actually consumes two cells of the parameter list:
</p>

<pre>
native static long addTwoLongs(long a, long b)

int64_t foo_Type3_addTwoLongs(SedonaVM* vm, Cell* params)
{
  int64_t a = *(int64_t*)(params+0); // param 0+1
  int64_t b = *(int64_t*)(params+2); // param 2+3
  return a+b;
}
</pre>

<p>
A summary of common mappings from Sedona to their C equivalents:
</p>

<table>
<tr>
  <th>Sedona</th> <th>C</th>
  <th></th>
  <th>Sedona</th> <th>C</th>
</tr>
<tr>
  <td>bool</td>   <td>int32_t</td>
  <td></td>
  <td>bool[]</td> <td>uint8_t*</td>
</tr>
<tr>
  <td>byte</td>   <td>int32_t</td>
  <td></td>
  <td>byte[]</td> <td>uint8_t*</td>
</tr>
<tr>
  <td>short</td>   <td>int32_t</td>
  <td></td>
  <td>short[]</td> <td>uint16_t*</td>
</tr>
<tr>
  <td>int</td>   <td>int32_t</td>
  <td></td>
  <td>int[]</td> <td>int32_t*</td>
</tr>
<tr>
  <td>long</td>   <td>int64_t</td>
  <td></td>
  <td>long[]</td> <td>int64_t*</td>
</tr>
<tr>
  <td>float</td>   <td>float</td>
  <td></td>
  <td>float[]</td> <td>float*</td>
</tr>
<tr>
  <td>double</td>   <td>double</td>
  <td></td>
  <td>double[]</td> <td>double*</td>
</tr>
<tr>
  <td>Obj</td>   <td>void*</td>
  <td></td>
  <td>Obj[]</td> <td>void**</td>
</tr>
<tr>
  <td>Str</td>   <td>uint8_t*</td>
  <td></td>
  <td>Str[]</td> <td>uint8_t**</td>
</tr>
</table>

<p>
Note that strings can be used as a normal null terminated C string.
</p>

<p>
Refer to the <a href='porting.html#natives'>Porting</a> chapter for how
to structure your native C code.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="tables">Native Tables</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
When the SVM is compiled, the SVM is bound to a lookup table
for all the native methods available.  This lookup table is a two
level array of function pointers.  The first level of the array
maps to the kitIds and the second level maps to the methodIds.  For
example the function pointer for the native id of
"2::7" would be <code>nativeTable[2][7]</code>.
</p>

<p>
The native lookup table is automatically generated as "nativetable.c"
when <code>sedonac</code> is used to <a href="porting.html#staging">stage a VM</a>.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="issues">Additional Issues</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The existing native method facility provides low level hooks to bind
Sedona Framework APIs into the native platform.  However due to its low level nature
it maps fairly closely to the stack architecture of the VM.  This design
has the major limitation that it only works well when accessing primitives
off the stack.  There is currently no safe mechanism to access individual
fields of an Object within a native method, as you would need to
know exactly how the compiler will layout the memory (even then it would
be quite brittle).  In the meantime the best
practice is to pass only primitives (or arrays of primitives) as parameters.
</p>

<!-- /////////////////////////////////////////////////////// -->
<h1 id="predefined">Predefined Kit Ids</h1>
<!-- /////////////////////////////////////////////////////// -->

<p>
The following table shows some of the currently predefined native kit ids.
All PlatformService kits use a native kit id of 1.
</p>

<table>
  <tr> <td>sys</td>                  <td>0</td></tr>
  <tr> <td><i>platform svcs</i></td> <td>1</td></tr>
  <tr> <td>inet</td>                 <td>2</td></tr>
  <tr> <td>serial</td>               <td>3</td></tr>
  <tr> <td>basicio</td>              <td>4</td></tr>
  <tr> <td>bacnet</td>               <td>5</td></tr>
  <tr> <td>smbus</td>                <td>6</td></tr>
  <tr> <td>spibus</td>               <td>7</td></tr>
  <tr> <td>nrio</td>                 <td>8</td></tr>
  <tr> <td>datetimeStd</td>          <td>9</td></tr>
</table>

<br/>

<!-- TOC-FOOTER-START -->
<!-- Auto-generated by sedonac -->
</div>
<div class='nav'>
  <a href='../index.html'>Index</a>
 | <a href='memory.html'>Prev</a>
 | <a href='logging.html'>Next</a>
</div>
<div class='copyright'><script type='text/javascript'>document.write("Copyright &#169; " + new Date().getFullYear() + " Tridium, Inc.")</script></div>
</body>
<!-- TOC-FOOTER-END -->

</html>







